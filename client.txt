app.js:
import VoiceChatClient from './modules/VoiceChatClient.js';

document.addEventListener('DOMContentLoaded', () => {
    window.client = new VoiceChatClient();
});


components/ChatArea.js:


components/MembersPanel.js:


components/Modal.js:


components/Sidebar.js:


modules/AuthManager.js:
import InviteManager from './InviteManager.js';

class AuthManager {
    static STORAGE_KEY = 'voicechat_users';
    static LAST_USER_KEY = 'voicechat_lastuser';

    static getAllUsers() {
        try {
            return JSON.parse(localStorage.getItem(this.STORAGE_KEY)) || {};
        } catch {
            return {};
        }
    }

    static saveAllUsers(users) {
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(users));
    }

    static loadLastUser() {
        try {
            return JSON.parse(localStorage.getItem(this.LAST_USER_KEY));
        } catch {
            return null;
        }
    }

    static saveLastUser(user) {
        localStorage.setItem(this.LAST_USER_KEY, JSON.stringify(user));
    }

    static removeUser(username) {
        const users = this.getAllUsers();
        delete users[username];
        this.saveAllUsers(users);
        
        const lastUser = this.loadLastUser();
        if (lastUser && lastUser.username === username) {
            localStorage.removeItem(this.LAST_USER_KEY);
        }
    }

    static async tryAutoLogin(client) {
        const lastUser = this.loadLastUser();
        if (!lastUser) return false;

        const isValid = await this.validateToken(client, lastUser.userId, lastUser.token);
        if (!isValid) {
            this.removeUser(lastUser.username);
            return false;
        }

        client.userId = lastUser.userId;
        client.token = lastUser.token;
        client.username = lastUser.username;
        
        // НОВОЕ: Инициализируем InviteManager после успешного авто-логина
        InviteManager.init(client);
        
        return true;
    }

    static async validateToken(client, userId, token) {
        try {
            const response = await fetch(`${client.API_SERVER_URL}/api/auth/validate`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({ userId, token })
            });

            if (!response.ok) return false;
            const data = await response.json();
            return data.valid === true;
        } catch (error) {
            return false;
        }
    }

    static async registerUser(client, username, password) {
        try {
            const response = await fetch(`${client.API_SERVER_URL}/api/auth`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password })
            });

            const responseText = await response.text();
            let data;
            try {
                data = JSON.parse(responseText);
            } catch (e) {
                throw new Error('Сервер вернул неверный формат данных');
            }

            if (!response.ok) {
                throw new Error(data.error || `Ошибка сервера: ${response.status}`);
            }

            const users = this.getAllUsers();
            users[username] = {
                username: username,
                password: password,
                userId: data.userId,
                token: data.token
            };
            this.saveAllUsers(users);
            this.saveLastUser({
                username: username,
                userId: data.userId,
                token: data.token
            });

            client.userId = data.userId;
            client.token = data.token;
            client.username = username;

            // НОВОЕ: Инициализируем InviteManager после регистрации
            InviteManager.init(client);
            
            return true;
        } catch (error) {
            throw error;
        }
    }

    static showAuthModal(client) {
        const users = this.getAllUsers();
        const savedUser = this.loadLastUser();
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.style.display = 'flex';
        modal.innerHTML = `
            <div class="modal-content">
                <h2>Выберите пользователя</h2>
                <div class="saved-users-list">
                    ${Object.keys(users).length === 0 
                        ? '<div class="no-users-message">Нет сохранённых пользователей</div>' 
                        : Object.values(users).map(u => `
                            <div class="saved-user-item" data-username="${u.username}">
                                <span>${u.username}</span>
                                <button class="remove-user-btn" data-user="${u.username}">✕</button>
                            </div>
                        `).join('')}
                </div>
                <input type="text" id="usernameInput" placeholder="Никнейм" value="${savedUser ? savedUser.username : ''}">
                <input type="password" id="passwordInput" placeholder="Пароль">
                <button id="authSubmitBtn">Войти</button>
                <button id="createNewUserBtn">➕ Создать нового</button>
            </div>
        `;
        document.body.appendChild(modal);
        
        const usernameInput = modal.querySelector('#usernameInput');
        const passwordInput = modal.querySelector('#passwordInput');
        const submitBtn = modal.querySelector('#authSubmitBtn');

        modal.querySelectorAll('.saved-user-item').forEach(item => {
            item.addEventListener('click', () => {
                const username = item.dataset.username;
                const user = users[username];
                usernameInput.value = username;
                passwordInput.value = user.password;
                passwordInput.focus();
            });
        });

        modal.querySelectorAll('.remove-user-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const username = btn.dataset.user;
                if (confirm(`Удалить пользователя ${username}?`)) {
                    this.removeUser(username);
                    modal.remove();
                    this.showAuthModal(client);
                }
            });
        });

        modal.querySelector('#createNewUserBtn').addEventListener('click', () => {
            usernameInput.value = '';
            passwordInput.value = '';
            usernameInput.focus();
        });

        const handleSubmit = async () => {
            const u = usernameInput.value.trim();
            const p = passwordInput.value.trim();
            if (u.length < 3 || p.length < 4) {
                alert('Ник — от 3, пароль — от 4');
                return;
            }
            try {
                const success = await this.registerUser(client, u, p);
                if (success) {
                    modal.remove();
                    
                    // НОВОЕ: Загружаем серверы через импорт
                    await import('./ServerManager.js').then(module => {
                        return module.default.loadServers(client);
                    });

                    // НОВОЕ: Применяем отложенный инвайт после авторизации
                    const inviteApplied = await InviteManager.applyPendingInvite();
                    
                    // Если инвайт был применен, он сам позаботится о навигации
                    if (inviteApplied) {
                        client.startSyncInterval();
                        return;
                    }

                    // Старая логика для обратной совместимости
                    if (client.inviteServerId) {
                        const serverExists = client.servers.some(s => s.id === client.inviteServerId);
                        if (serverExists) {
                            client.currentServerId = client.inviteServerId;
                            await import('./RoomManager.js').then(module => {
                                return module.default.loadRoomsForServer(client, client.inviteServerId);
                            });
                            client.startSyncInterval();
                            return;
                        }
                    }

                    if (client.currentServerId) {
                        await import('./RoomManager.js').then(module => {
                            return module.default.loadRoomsForServer(client, client.currentServerId);
                        });
                        client.startSyncInterval();
                    }
                    if (client.currentRoom) {
                        await client.reconnectToRoom(client.currentRoom);
                    }
                }
            } catch (error) {
                alert('Ошибка: ' + error.message);
            }
        };

        submitBtn.addEventListener('click', handleSubmit);
        passwordInput.addEventListener('keypress', e => {
            if (e.key === 'Enter') handleSubmit();
        });

        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });
        
        // НОВОЕ: Инициализируем InviteManager при показе модального окна
        InviteManager.init(client);
    }
}

export default AuthManager;


modules/ChatManager.js:
import UIManager from './UIManager.js';

class ChatManager {
    static async loadMessages(client, roomId) {
        try {
            const response = await fetch(`${client.API_SERVER_URL}/api/rooms/${roomId}/messages`, {
                headers: {
                    'Authorization': `Bearer ${client.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.ok) {
                const data = await response.json();
                if (data.messages && Array.isArray(data.messages)) {
                    data.messages.forEach(message => {
                        const username = message.username || 'Unknown';
                        UIManager.addMessage(username, message.text, message.timestamp);
                    });
                }
            }
        } catch (error) {}
    }

    static async sendMessage(client, text) {
        if (!text.trim() || !client.currentRoom) return;

        try {
            const response = await fetch(`${client.API_SERVER_URL}/api/messages`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${client.token}`
                },
                body: JSON.stringify({
                    roomId: client.currentRoom,
                    text: text.trim(),
                    userId: client.userId
                })
            });

            if (!response.ok) {
                throw new Error('Ошибка отправки сообщения');
            }
        } catch (error) {
            UIManager.showError('Не удалось отправить сообщение');
        }
    }

    static setupSocketHandlers(client) {
        if (!client.socket) return;

        client.socket.on('new-message', (data) => {
            const username = data.username || 'Unknown';
            UIManager.addMessage(username, data.text, data.timestamp);
        });

        client.socket.on('message-history', (messages) => {
            messages.forEach(msg => {
                const username = msg.username || 'Unknown';
                UIManager.addMessage(username, msg.text, msg.timestamp);
            });
        });
    }
}

export default ChatManager;


modules/InviteManager.js:
import UIManager from './UIManager.js';

class InviteManager {
    static STORAGE_KEY = 'pending_invite';
    static INVITE_CODE_REGEX = /^[a-zA-Z0-9]{4}$/;

    static init(client) {
        this.client = client;
        this.processUrlParams();
    }

    static processUrlParams() {
        const params = new URLSearchParams(window.location.search);
        const inviteCode = params.get('invite');
        
        if (inviteCode && this.isValidInviteCode(inviteCode)) {
            this.setPendingInvite(inviteCode);
            this.cleanUrlParams();
        }
    }

    static isValidInviteCode(code) {
        return this.INVITE_CODE_REGEX.test(code);
    }

    static setPendingInvite(code) {
        localStorage.setItem(this.STORAGE_KEY, code);
    }

    static getPendingInvite() {
        return localStorage.getItem(this.STORAGE_KEY);
    }

    static clearPendingInvite() {
        localStorage.removeItem(this.STORAGE_KEY);
    }

    static cleanUrlParams() {
        const url = new URL(window.location);
        url.searchParams.delete('invite');
        window.history.replaceState({}, '', url);
    }

    static async applyPendingInvite() {
        const inviteCode = this.getPendingInvite();
        if (!inviteCode || !this.client.token) {
            return false;
        }

        try {
            const inviteInfo = await this.getInviteInfo(inviteCode);
            if (!inviteInfo) {
                this.clearPendingInvite();
                return false;
            }

            let success = false;
            if (inviteInfo.invite.targetType === 'server') {
                success = await this.joinServerByInvite(inviteInfo);
            } else if (inviteInfo.invite.targetType === 'room') {
                success = await this.joinRoomByInvite(inviteInfo);
            }

            if (success) {
                this.clearPendingInvite();
                UIManager.addMessage('System', `✅ Присоединение по приглашению успешно`);
            }

            return success;
        } catch (error) {
            console.error('Ошибка применения инвайта:', error);
            UIManager.showError('Не удалось применить приглашение');
            this.clearPendingInvite();
            return false;
        }
    }

    static async getInviteInfo(inviteCode) {
        try {
            const response = await fetch(`${this.client.API_SERVER_URL}/api/invites/${inviteCode}`, {
                headers: {
                    'Authorization': `Bearer ${this.client.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error: ${response.status}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Ошибка получения информации об инвайте:', error);
            throw error;
        }
    }

    static async joinServerByInvite(inviteInfo) {
        try {
            const { invite } = inviteInfo;
            
            const serverExists = this.client.servers.some(s => s.id === invite.targetId);
            if (serverExists) {
                this.client.currentServerId = invite.targetId;
                UIManager.addMessage('System', `Вы уже присоединены к серверу "${invite.targetInfo.name}"`);
                return true;
            }

            const response = await fetch(`${this.client.API_SERVER_URL}/api/servers/${invite.targetId}/join`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.client.token}`
                },
                body: JSON.stringify({
                    userId: this.client.userId,
                    token: this.client.token
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `Ошибка присоединения: ${response.status}`);
            }

            const data = await response.json();
            
            const serverExistsInList = this.client.servers.some(s => s.id === data.server.id);
            if (!serverExistsInList) {
                this.client.servers.push(data.server);
            }
            
            this.client.currentServerId = data.server.id;
            this.client.currentServer = data.server;

            UIManager.addMessage('System', `✅ Вы присоединились к серверу "${data.server.name}" по приглашению`);
            
            // Загружаем комнаты сервера
            const RoomManager = await import('./RoomManager.js').then(module => module.default);
            await RoomManager.loadRoomsForServer(this.client, data.server.id);

            return true;
        } catch (error) {
            console.error('Ошибка присоединения к серверу по инвайту:', error);
            UIManager.showError(`Не удалось присоединиться к серверу: ${error.message}`);
            return false;
        }
    }

    static async joinRoomByInvite(inviteInfo) {
        try {
            const { invite } = inviteInfo;
            
            // Используем информацию из инвайта, а не делаем дополнительный запрос
            if (!invite.targetInfo || !invite.targetInfo.serverId) {
                throw new Error('Недостаточно информации о комнате в приглашении');
            }

            const serverId = invite.targetInfo.serverId;
            
            // Проверяем, присоединены ли мы к серверу
            const serverExists = this.client.servers.some(s => s.id === serverId);
            if (!serverExists) {
                // Сначала присоединяемся к серверу
                const serverJoinSuccess = await this.joinServerByInvite({
                    invite: {
                        ...invite,
                        targetId: serverId,
                        targetType: 'server',
                        targetInfo: { name: invite.targetInfo.serverName }
                    }
                });
                
                if (!serverJoinSuccess) {
                    throw new Error('Не удалось присоединиться к серверу комнаты');
                }
            }

            this.client.currentServerId = serverId;
            this.client.currentRoom = invite.targetId;

            // Загружаем комнаты сервера
            const RoomManager = await import('./RoomManager.js').then(module => module.default);
            await RoomManager.loadRoomsForServer(this.client, serverId);
            
            // Присоединяемся к комнате
            await RoomManager.joinRoom(this.client, invite.targetId);

            UIManager.addMessage('System', `✅ Вы присоединились к комнате "${invite.targetInfo.name}" по приглашению`);
            
            return true;
        } catch (error) {
            console.error('Ошибка присоединения к комнате по инвайту:', error);
            UIManager.showError(`Не удалось присоединиться к комнате: ${error.message}`);
            return false;
        }
    }

    static async createServerInvite(serverId, expiresInHours = 168) {
        try {
            const response = await fetch(`${this.client.API_SERVER_URL}/api/invites`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.client.token}`
                },
                body: JSON.stringify({
                    targetId: serverId,
                    targetType: 'server',
                    expiresInHours
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error: ${response.status}`);
            }

            const data = await response.json();
            return data.invite;
        } catch (error) {
            console.error('Ошибка создания инвайта сервера:', error);
            throw error;
        }
    }

    static async createRoomInvite(roomId, expiresInHours = 168) {
        try {
            const response = await fetch(`${this.client.API_SERVER_URL}/api/invites`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.client.token}`
                },
                body: JSON.stringify({
                    targetId: roomId,
                    targetType: 'room',
                    expiresInHours
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error: ${response.status}`);
            }

            const data = await response.json();
            return data.invite;
        } catch (error) {
            console.error('Ошибка создания инвайта комнаты:', error);
            throw error;
        }
    }

    static async getServerInvites(serverId) {
        try {
            const response = await fetch(`${this.client.API_SERVER_URL}/api/servers/${serverId}/invites`, {
                headers: {
                    'Authorization': `Bearer ${this.client.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error: ${response.status}`);
            }

            const data = await response.json();
            return data.invites;
        } catch (error) {
            console.error('Ошибка получения инвайтов сервера:', error);
            throw error;
        }
    }

    static async getRoomInvites(roomId) {
        try {
            const response = await fetch(`${this.client.API_SERVER_URL}/api/rooms/${roomId}/invites`, {
                headers: {
                    'Authorization': `Bearer ${this.client.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error: ${response.status}`);
            }

            const data = await response.json();
            return data.invites;
        } catch (error) {
            console.error('Ошибка получения инвайтов комнаты:', error);
            throw error;
        }
    }

    static generateInviteLink(code) {
        return `https://ns.fiber-gate.ru/${code}`;
    }

    static copyInviteLink(code) {
        const link = this.generateInviteLink(code);
        navigator.clipboard.writeText(link)
            .then(() => {
                UIManager.showError('Ссылка скопирована в буфер обмена');
            })
            .catch(err => {
                console.error('Ошибка копирования ссылки:', err);
                UIManager.showError('Не удалось скопировать ссылку');
            });
    }
}

export default InviteManager;


modules/MediaManager.js:
class MediaManager {
    static async connect(client, roomId, mediaData) {
        console.log('MediaManager connecting to room:', roomId);
        
        try {
            if (typeof mediasoupClient === 'undefined') {
                throw new Error('Библиотека mediasoup-client не загружена');
            }
            
            client.device = new mediasoupClient.Device();
            await client.device.load({ routerRtpCapabilities: mediaData.rtpCapabilities });
            
            await this.createTransports(client, mediaData);
            this.startKeepAlive(client, roomId);
            
            client.isConnected = true;
            client.isMicActive = false;
            client.existingProducers = new Set();
            client.consumers = new Map();
            
            await this.requestCurrentProducers(client, roomId);
            
            console.log('MediaManager connected successfully');
            
        } catch (error) {
            console.error('MediaManager connection failed:', error);
            throw new Error(`Media connection failed: ${error.message}`);
        }
    }

    static async createTransports(client, mediaData) {
        console.log('Creating transports for client:', client.clientID);
        
        try {
            if (!client.sendTransport) {
                console.log('Creating send transport');
                client.sendTransport = client.device.createSendTransport({
                    id: mediaData.sendTransport.id,
                    iceParameters: mediaData.sendTransport.iceParameters,
                    iceCandidates: mediaData.sendTransport.iceCandidates,
                    dtlsParameters: mediaData.sendTransport.dtlsParameters
                });
                this.setupSendTransportHandlers(client);
            } else {
                console.log('Send transport already exists, reusing');
            }
            
            if (!client.recvTransport) {
                console.log('Creating receive transport');
                client.recvTransport = client.device.createRecvTransport({
                    id: mediaData.recvTransport.id,
                    iceParameters: mediaData.recvTransport.iceParameters,
                    iceCandidates: mediaData.recvTransport.iceCandidates,
                    dtlsParameters: mediaData.recvTransport.dtlsParameters
                });
                this.setupRecvTransportHandlers(client);
            } else {
                console.log('Receive transport already exists, reusing');
            }
            
        } catch (error) {
            console.error('Error creating transports:', error);
            throw error;
        }
    }

    static setupSendTransportHandlers(client) {
        console.log('Setting up send transport handlers');
        
        client.sendTransport.on('connect', async ({ dtlsParameters }, callback, errback) => {
            console.log('Send transport connecting...');
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                
                await fetch(`${client.API_SERVER_URL}/api/media/transport/connect`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${client.token}`
                    },
                    body: JSON.stringify({
                        transportId: client.sendTransport.id,
                        dtlsParameters: dtlsParameters
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                console.log('Send transport connected successfully');
                callback();
            } catch (error) {
                console.error('Send transport connection failed:', error);
                errback(error);
            }
        });
        
        client.sendTransport.on('produce', async (parameters, callback, errback) => {
            console.log('Producing media:', parameters.kind);
            
            try {
                const response = await fetch(`${client.API_SERVER_URL}/api/media/produce`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${client.token}`
                    },
                    body: JSON.stringify({
                        transportId: client.sendTransport.id,
                        kind: parameters.kind,
                        rtpParameters: parameters.rtpParameters,
                        clientId: client.clientID,
                        roomId: client.currentRoom
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Produce failed:', response.status, errorText);
                    throw new Error(`HTTP error: ${response.status}`);
                }
                
                const data = await response.json();
                
                await fetch(`${client.API_SERVER_URL}/api/media/notify-new-producer`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${client.token}`
                    },
                    body: JSON.stringify({
                        roomId: client.currentRoom,
                        producerId: data.producerId,
                        clientID: client.clientID,
                        kind: parameters.kind
                    })
                });
                
                console.log('Media produced successfully:', data.producerId);
                callback({ id: data.producerId });
            } catch (error) {
                console.error('Produce failed:', error);
                errback(error);
            }
        });
    }

    static setupRecvTransportHandlers(client) {
        console.log('Setting up receive transport handlers');
        
        client.recvTransport.on('connect', async ({ dtlsParameters }, callback, errback) => {
            console.log('Receive transport connecting...');
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                
                await fetch(`${client.API_SERVER_URL}/api/media/transport/connect`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${client.token}`
                    },
                    body: JSON.stringify({
                        transportId: client.recvTransport.id,
                        dtlsParameters: dtlsParameters
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                console.log('Receive transport connected successfully');
                callback();
            } catch (error) {
                console.error('Receive transport connection failed:', error);
                errback(error);
            }
        });
    }

    static async startMicrophone(client) {
        console.log('Starting microphone for client:', client.clientID);
        
        try {
            if (!client.sendTransport) {
                throw new Error('Send transport не инициализирован');
            }
            
            client.stream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    sampleRate: 48000,
                    channelCount: 2
                }
            });
            
            const track = client.stream.getAudioTracks()[0];
            client.audioProducer = await client.sendTransport.produce({
                track,
                encodings: [{ 
                    maxBitrate: 64000,
                    dtx: true
                }],
                codecOptions: {
                    opusStereo: true,
                    opusDtx: true,
                    opusFec: true
                },
                appData: { 
                    clientID: client.clientID, 
                    roomId: client.currentRoom 
                }
            });
            
            client.isMicActive = true;
            console.log('Microphone started successfully');
            
            if (client.socket && client.audioProducer) {
                client.socket.emit('new-producer-notification', {
                    roomId: client.currentRoom,
                    producerId: client.audioProducer.id,
                    clientID: client.clientID,
                    kind: 'audio'
                });
            }
            
        } catch (error) {
            console.error('Microphone start failed:', error);
            
            if (client.stream) {
                client.stream.getTracks().forEach(track => track.stop());
                client.stream = null;
            }
            
            throw new Error(`Microphone failed: ${error.message}`);
        }
    }

    static async stopMicrophone(client) {
        console.log('Stopping microphone for client:', client.clientID);
        
        try {
            if (client.audioProducer) {
                try {
                    await fetch(`${client.API_SERVER_URL}/api/media/producer/close`, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${client.token}`
                        },
                        body: JSON.stringify({
                            producerId: client.audioProducer.id
                        })
                    });
                } catch (error) {
                    console.warn('Error closing producer on server:', error);
                }
                
                client.audioProducer.close();
                client.audioProducer = null;
            }
            
            if (client.stream) {
                client.stream.getTracks().forEach(track => track.stop());
                client.stream = null;
            }
            
            client.isMicActive = false;
            console.log('Microphone stopped successfully');
            
        } catch (error) {
            console.error('Microphone stop failed:', error);
            throw new Error(`Microphone stop failed: ${error.message}`);
        }
    }

    static startKeepAlive(client, roomId) {
        console.log('Starting keep-alive for client:', client.clientID);
        
        if (client.keepAliveInterval) {
            clearInterval(client.keepAliveInterval);
        }
        
        client.keepAliveInterval = setInterval(() => {
            fetch(`${client.API_SERVER_URL}/api/media/health`, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${client.token}`
                },
                body: JSON.stringify({
                    clientId: client.clientID,
                    roomId: roomId
                })
            }).catch(() => {
                console.warn('Keep-alive request failed');
            });
        }, 10000);
    }

    static async requestCurrentProducers(client, roomId) {
        console.log('Requesting current producers for room:', roomId);
        
        try {
            const response = await fetch(`${client.API_SERVER_URL}/api/media/rooms/${roomId}/producers`, {
                headers: {
                    'Authorization': `Bearer ${client.token}`,
                    'Content-Type': 'application/json'
                }
            });
            
            if (!response.ok) {
                console.warn('Failed to get producers list:', response.status);
                return;
            }
            
            const data = await response.json();
            
            if (!data || !data.producers || !Array.isArray(data.producers)) {
                console.warn('Invalid producers data received:', data);
                return;
            }
            
            console.log('Found', data.producers.length, 'producers in room');
            
            for (const producer of data.producers) {
                if (producer.clientID !== client.clientID && 
                    !client.existingProducers.has(producer.id)) {
                    try {
                        await this.createConsumer(client, producer.id);
                        client.existingProducers.add(producer.id);
                    } catch (error) {
                        console.error('Error creating consumer for producer:', producer.id, error);
                    }
                }
            }
        } catch (error) {
            console.error('Error requesting current producers:', error);
        }
    }

    static async createConsumer(client, producerId) {
        console.log('Creating consumer for producer:', producerId);
        
        if (client.audioProducer && client.audioProducer.id === producerId) {
            console.log('Skipping own producer');
            throw new Error('Cannot consume own producer');
        }
        
        if (client.consumers.has(producerId)) {
            console.log('Consumer already exists for producer:', producerId);
            const existingConsumer = client.consumers.get(producerId);
            
            if (existingConsumer.closed || existingConsumer.transportClosed) {
                console.log('Existing consumer is closed, creating new one');
                client.consumers.delete(producerId);
            } else {
                return existingConsumer;
            }
        }
        
        try {
            const response = await fetch(`${client.API_SERVER_URL}/api/media/consume`, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${client.token}`
                },
                body: JSON.stringify({
                    producerId: producerId,
                    rtpCapabilities: client.device.rtpCapabilities,
                    transportId: client.recvTransport.id,
                    clientId: client.clientID
                })
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('HTTP error:', response.status, errorText);
                
                if (response.status === 400 && errorText.includes('own audio')) {
                    throw new Error('Cannot consume own audio');
                }
                
                throw new Error(`HTTP error: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (!data || !data.id) {
                console.error('Invalid consumer data received:', data);
                throw new Error('Invalid consumer data received');
            }
            
            console.log('Consumer data received from server:', data.id);
            
            const consumer = await client.recvTransport.consume({
                id: data.id,
                producerId: data.producerId,
                kind: data.kind,
                rtpParameters: data.rtpParameters
            });
            
            client.consumers.set(producerId, consumer);
            
            let audioElement = window.audioElements?.get(producerId);
            
            if (!audioElement || audioElement.closed) {
                audioElement = new Audio();
                audioElement.id = `audio-${producerId}`;
                audioElement.autoplay = true;
                audioElement.volume = 0.8;
                audioElement.style.display = 'none';
                
                if (!window.audioElements) window.audioElements = new Map();
                window.audioElements.set(producerId, audioElement);
                document.body.appendChild(audioElement);
            }
            
            const stream = new MediaStream([consumer.track.clone()]);
            audioElement.srcObject = stream;
            
            consumer.on('transportclose', () => {
                console.log('Consumer transport closed:', consumer.id);
                consumer.transportClosed = true;
            });
            
            consumer.on('trackended', () => {
                console.log('Consumer track ended:', consumer.id);
            });
            
            console.log('Consumer created successfully:', data.id);
            return consumer;
            
        } catch (error) {
            console.error('Error creating consumer:', error);
            
            if (error.message.includes('consume own') || 
                error.message.includes('own audio') || 
                error.message.includes('400') ||
                error.message.includes('Cannot consume own')) {
                client.existingProducers.add(producerId);
                console.log('Added to excluded producers:', producerId);
            }
            
            throw error;
        }
    }

    static disconnect(client) {
        console.log('Disconnecting media for client:', client.clientID);
        
        if (client.keepAliveInterval) {
            clearInterval(client.keepAliveInterval);
            client.keepAliveInterval = null;
        }
        
        if (client.isMicActive) {
            this.stopMicrophone(client).catch(() => {
                console.warn('Error stopping microphone during disconnect');
            });
        }
        
        if (client.sendTransport) {
            try {
                client.sendTransport.close();
            } catch (error) {
                console.warn('Error closing send transport:', error);
            }
            client.sendTransport = null;
        }
        
        if (client.recvTransport) {
            try {
                client.recvTransport.close();
            } catch (error) {
                console.warn('Error closing receive transport:', error);
            }
            client.recvTransport = null;
        }
        
        client.consumers.forEach(consumer => {
            try {
                consumer.close();
            } catch (error) {
                console.warn('Error closing consumer:', error);
            }
        });
        client.consumers.clear();
        
        if (window.audioElements) {
            window.audioElements.forEach(audio => {
                try {
                    audio.pause();
                    audio.srcObject = null;
                    audio.remove();
                } catch (error) {
                    console.warn('Error cleaning up audio element:', error);
                }
            });
            window.audioElements.clear();
        }
        
        client.device = null;
        client.isConnected = false;
        client.existingProducers.clear();
        
        console.log('Media disconnected successfully');
    }

    static async handleNewProducer(client, producerData) {
        console.log('Handling new producer notification:', producerData);
        
        if (producerData.clientID !== client.clientID && 
            !client.existingProducers.has(producerData.producerId)) {
            try {
                await this.createConsumer(client, producerData.producerId);
                client.existingProducers.add(producerData.producerId);
            } catch (error) {
                console.error('Error creating consumer from notification:', error);
            }
        }
    }
}

export default MediaManager;


modules/MembersManager.js:
import UIManager from './UIManager.js';

class MembersManager {
    static members = new Map();

    static updateMember(userId, updates) {
        if (this.members.has(userId)) {
            const member = { ...this.members.get(userId), ...updates };
            this.members.set(userId, member);
            UIManager.updateMembersList(Array.from(this.members.values()));
            
            // Обновляем UI для конкретного участника
            UIManager.updateMemberMicState(userId, updates.isMicActive);
        }
    }

    static addMember(memberData) {
        if (!memberData.userId) {
            console.error('Member data must contain userId');
            return;
        }

        const processedMemberData = {
            userId: memberData.userId,
            username: memberData.username || `User_${memberData.userId.substr(0, 8)}`,
            isMicActive: memberData.isMicActive || false,
            isOnline: true,
            clientId: memberData.clientId || null
        };

        if (!this.members.has(processedMemberData.userId)) {
            this.members.set(processedMemberData.userId, processedMemberData);
            UIManager.updateMembersList(Array.from(this.members.values()));
        } else {
            this.updateMember(processedMemberData.userId, processedMemberData);
        }
    }

    static removeMember(userId) {
        if (this.members.has(userId)) {
            this.members.delete(userId);
            UIManager.updateMembersList(Array.from(this.members.values()));
        }
    }

    static clearMembers() {
        this.members.clear();
        UIManager.updateMembersList([]);
    }

    static updateAllMembers(members) {
        this.members.clear();
        members.forEach(member => this.addMember(member));
    }

    static setupSocketHandlers(client) {
        if (!client.socket) return;

        client.socket.on('room-participants', (participants) => {
            this.updateAllMembers(participants);
        });

        client.socket.on('user-joined', (user) => {
            this.addMember(user);
        });

        client.socket.on('user-left', (data) => {
            this.removeMember(data.userId);
        });

        client.socket.on('user-mic-state', (data) => {
            if (data.userId) {
                this.updateMember(data.userId, { isMicActive: data.isActive });
            } else if (data.clientID) {
                // Находим пользователя по clientID
                const members = Array.from(this.members.values());
                const member = members.find(m => m.clientId === data.clientID);
                if (member) {
                    this.updateMember(member.userId, { isMicActive: data.isActive });
                }
            }
        });
    }

    static setupSSEHandlers() {
        console.log('SSE handlers for members are setup in TextChatManager');
    }

    static getMembers() {
        return Array.from(this.members.values());
    }

    static getMember(userId) {
        return this.members.get(userId);
    }

    static isCurrentUser(client, userId) {
        return client.userId === userId;
    }

    static initializeRoomMembers(client, participants) {
        console.log('Initializing room members with:', participants);
        this.clearMembers();
        participants.forEach(participant => this.addMember(participant));
    }
}

export default MembersManager;


modules/RoomManager.js:
import UIManager from './UIManager.js';
import MediaManager from './MediaManager.js';
import TextChatManager from './TextChatManager.js';
import MembersManager from './MembersManager.js';
import InviteManager from './InviteManager.js';

class RoomManager {
  static async loadRoomsForServer(client, serverId) {
    try {
      client.currentServerId = serverId;
      client.currentServer = client.servers.find(s => s.id === serverId) || null;
      UIManager.updateStatus('Загрузка комнат...', 'connecting');
      
      const res = await fetch(`${client.API_SERVER_URL}/api/servers/${serverId}/rooms`, {
        headers: {
          'Authorization': `Bearer ${client.token}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (!res.ok) {
        const errorData = await res.json().catch(() => ({}));
        throw new Error(`Не удалось загрузить комнаты: ${errorData.error || res.statusText}`);
      }
      
      const data = await res.json();
      if (!data || !Array.isArray(data.rooms)) {
        throw new Error('Некорректные данные от сервера');
      }
      
      // СОХРАНЯЕМ КОМНАТЫ В КЛИЕНТЕ
      client.rooms = data.rooms;
      
      this.renderRooms(client, data.rooms);
      UIManager.updateStatus('Комнаты загружены', 'normal');
      
    } catch (error) {
      UIManager.updateStatus('Ошибка загрузки комнат', 'error');
      UIManager.showError('Не удалось загрузить комнаты: ' + error.message);
    }
  }

  static async joinRoom(client, roomId) {
    try {
      const res = await fetch(`${client.API_SERVER_URL}/api/rooms/${roomId}/join`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${client.token}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (!res.ok) {
        const errorData = await res.json().catch(() => ({}));
        throw new Error(errorData.error || `Ошибка присоединения к комнате: ${res.status}`);
      }
      
      const data = await res.json();
      client.currentRoom = roomId;
      client.roomType = 'voice';
      
      try {
        await MediaManager.connect(client, roomId, data.mediaData);
        UIManager.updateRoomUI(client);
        await MediaManager.startConsumingProducers(client);
      } catch (mediaError) {
        UIManager.showError('Не удалось подключиться к комнате: ' + mediaError.message);
        throw mediaError;
      }
      
      UIManager.updateRoomUI(client);
      TextChatManager.joinTextRoom(client, roomId);
      await TextChatManager.loadMessages(client, roomId);
      
      UIManager.addMessage('System', `✅ Вы присоединились к комнате`);
      return true;
    } catch (error) {
      UIManager.showError('Не удалось присоединиться к комнате: ' + error.message);
      throw error;
    }
  }

  static async leaveRoom(client) {
    if (!client.currentRoom) return;
    
    try {
      if (client.isConnected) {
        MediaManager.disconnect(client);
      }
      
      await fetch(`${client.API_SERVER_URL}/api/rooms/${client.currentRoom}/leave`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${client.token}`,
          'Content-Type': 'application/json'
        }
      });
      
      MembersManager.clearMembers();
      
      client.currentRoom = null;
      client.roomType = null;
      
      UIManager.updateRoomUI(client);
      UIManager.addMessage('System', `✅ Вы покинули комнату`);
      return true;
    } catch (error) {
      UIManager.showError('Ошибка при покидании комнаты: ' + error.message);
      return false;
    }
  }

  static async createRoom(client, serverId, name) {
    if (!name || name.length < 3) {
      alert('Название должно быть от 3 символов');
      return;
    }
    
    try {
      const res = await fetch(`${client.API_SERVER_URL}/api/rooms`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${client.token}`
        },
        body: JSON.stringify({
          name: name.trim(),
          serverId: serverId,
          type: 'voice',
          userId: client.userId,
          token: client.token
        })
      });
      
      if (!res.ok) {
        const errorData = await res.json().catch(() => ({}));
        const errorMessage = errorData.error || 'Не удалось создать комнату';
        if (errorMessage.includes('уже существует')) {
          alert(`Ошибка: ${errorMessage}. Выберите другое название.`);
        } else {
          throw new Error(errorMessage);
        }
        return;
      }
      
      const data = await res.json();
      const roomData = data.room;
      
      if (client.currentServerId === serverId) {
        await this.loadRoomsForServer(client, serverId);
      }
      
      UIManager.addMessage('System', `✅ Создана комната "${name}"`);
    } catch (error) {
      alert('Ошибка: ' + error.message);
    }
  }

  static async createRoomInvite(client, roomId) {
    try {
      const invite = await InviteManager.createRoomInvite(roomId);
      
      if (invite) {
        const inviteLink = InviteManager.generateInviteLink(invite.code);
        
        UIManager.openModal('Приглашение создано', `
          <p>Приглашение для комнаты создано!</p>
          <div class="invite-link-container">
            <input type="text" id="inviteLinkInput" value="${inviteLink}" readonly>
            <button onclick="navigator.clipboard.writeText('${inviteLink}').then(() => alert('Ссылка скопирована!'))">Копировать</button>
          </div>
          <p>Ссылка действительна до: ${new Date(invite.expiresAt).toLocaleDateString()}</p>
        `, () => {
          UIManager.closeModal();
        });
      }
    } catch (error) {
      console.error('Ошибка создания инвайта комнаты:', error);
      UIManager.showError('Не удалось создать приглашение: ' + error.message);
    }
  }

  static async copyRoomInviteLink(client, roomId) {
    try {
      const invites = await InviteManager.getRoomInvites(roomId);
      
      if (invites && invites.length > 0) {
        const activeInvite = invites.find(invite => new Date(invite.expiresAt) > new Date());
        
        if (activeInvite) {
          InviteManager.copyInviteLink(activeInvite.code);
          return;
        }
      }
      
      const invite = await InviteManager.createRoomInvite(roomId);
      if (invite) {
        InviteManager.copyInviteLink(invite.code);
      }
    } catch (error) {
      console.error('Ошибка копирования ссылки инвайта комнаты:', error);
      UIManager.showError('Не удалось скопировать ссылку приглашения');
    }
  }

  static async deleteRoom(client, roomId) {
    if (!confirm('Вы уверены, что хотите удалить эту комнату?')) return;
    
    try {
      const res = await fetch(`${client.API_SERVER_URL}/api/rooms/${roomId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${client.token}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (!res.ok) {
        const errorData = await res.json().catch(() => ({}));
        throw new Error(errorData.error || 'Не удалось удалить комнату');
      }
      
      if (client.currentServerId) {
        await this.loadRoomsForServer(client, client.currentServerId);
      }
      
      if (client.currentRoom === roomId) {
        await this.leaveRoom(client);
      }
      
      UIManager.addMessage('System', `✅ Комната удалена`);
    } catch (error) {
      UIManager.showError('Ошибка: ' + error.message);
    }
  }

  static async reconnectToRoom(client, roomId) {
    try {
      UIManager.addMessage('System', 'Переподключение к комнате...');
      
      client.wasMicActiveBeforeReconnect = client.isMicActive;
      
      if (client.isMicActive && client.mediaData) {
        await MediaManager.stopMicrophone(client);
      }
      
      await this.leaveRoom(client);
      
      client.isReconnecting = true;
      
      await new Promise(resolve => setTimeout(resolve, 500));
      
      const result = await this.joinRoom(client, roomId);
      
      client.isReconnecting = false;
      
      if (client.wasMicActiveBeforeReconnect && client.mediaData) {
        setTimeout(async () => {
          try {
            await MediaManager.startMicrophone(client);
            client.wasMicActiveBeforeReconnect = false;
          } catch (error) {
            UIManager.showError('Не удалось восстановить микрофон после переподключения');
          }
        }, 1000);
      }
      
      return result;
    } catch (error) {
      client.isReconnecting = false;
      UIManager.addMessage('System', 'Ошибка переподключения: ' + error.message);
      throw error;
    }
  }

  static renderRooms(client, rooms) {
    const roomsList = document.querySelector('.rooms-list');
    if (!roomsList) return;

    roomsList.innerHTML = '';
    
    rooms.forEach(room => {
      const roomElement = document.createElement('div');
      roomElement.className = 'room-item';
      roomElement.dataset.room = room.id;
      
      const isOwner = room.ownerId === client.userId;
      const isMember = client.currentServer?.members?.includes(client.userId);
      
      roomElement.innerHTML = `🔊 ${room.name} ${isOwner ? '<span class="owner-badge">(Вы)</span>' : ''}`;
      
      roomElement.addEventListener('click', () => {
        client.currentRoom = room.id;
        client.joinRoom(room.id);
        
        localStorage.setItem('lastRoomId', room.id);
        localStorage.setItem('lastServerId', client.currentServerId);
      });
      
      if (isMember) {
        const actionButtons = document.createElement('div');
        actionButtons.className = 'room-actions';
        
        const shareBtn = document.createElement('button');
        shareBtn.className = 'room-action-btn';
        shareBtn.innerHTML = '📋';
        shareBtn.title = 'Скопировать ссылку на комнату';
        shareBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          try {
            const invite = await InviteManager.createRoomInvite(room.id);
            const inviteLink = InviteManager.generateInviteLink(invite.code);
            
            await navigator.clipboard.writeText(inviteLink);
            UIManager.showError('Ссылка скопирована!');
          } catch (error) {
            console.error('Ошибка копирования ссылки:', error);
            UIManager.showError('Не удалось скопировать ссылку');
          }
        });
        
        actionButtons.appendChild(shareBtn);
        
        if (isOwner) {
          const inviteBtn = document.createElement('button');
          inviteBtn.className = 'room-action-btn';
          inviteBtn.innerHTML = '🔗';
          inviteBtn.title = 'Создать приглашение';
          inviteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.createRoomInvite(client, room.id);
          });
          
          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'room-action-btn';
          deleteBtn.innerHTML = '✕';
          deleteBtn.title = 'Удалить комнату';
          deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.deleteRoom(client, room.id);
          });
          
          actionButtons.appendChild(inviteBtn);
          actionButtons.appendChild(deleteBtn);
        }
        
        roomElement.appendChild(actionButtons);
      }
      
      roomsList.appendChild(roomElement);
    });
  }
}

export default RoomManager;


modules/ServerManager.js:
import UIManager from './UIManager.js';
import RoomManager from './RoomManager.js';
import InviteManager from './InviteManager.js';

class ServerManager {
    static cachedServers = null;
    static lastUpdateTime = 0;
    static CACHE_DURATION = 30000; // 30 секунд кеширования

    static getLocalStorageKey(client) {
        return client.userId ? `voiceChatServers_${client.userId}` : null;
    }

    static saveServersToLocalStorage(client) {
        if (!client.userId) return;
        const key = this.getLocalStorageKey(client);
        const serversData = {
            servers: client.servers,
            timestamp: Date.now()
        };
        localStorage.setItem(key, JSON.stringify(serversData));
    }

    static loadServersFromLocalStorage(client) {
        if (!client.userId) return [];
        const key = this.getLocalStorageKey(client);
        const data = localStorage.getItem(key);
        if (data) {
            try {
                const serversData = JSON.parse(data);
                return serversData.servers || [];
            } catch (e) {
                return [];
            }
        }
        return [];
    }

    static async loadServers(client, forceUpdate = false) {
        try {
            // Используем кеширование для уменьшения запросов
            const now = Date.now();
            if (!forceUpdate && this.cachedServers && (now - this.lastUpdateTime) < this.CACHE_DURATION) {
                client.servers = this.cachedServers;
                this.renderServers(client);
                return true;
            }
            
            let servers = [];
            
            try {
                const res = await fetch(`${client.API_SERVER_URL}/api/servers`, {
                    headers: { 'Authorization': `Bearer ${client.token}` }
                });
                if (res.ok) {
                    const data = await res.json();
                    servers = Array.isArray(data.servers) ? data.servers : [];
                    
                    // Обновляем кеш
                    this.cachedServers = servers;
                    this.lastUpdateTime = now;
                }
            } catch (apiError) {
                servers = this.loadServersFromLocalStorage(client);
            }
            
            client.servers = servers;
            this.renderServers(client);
            return true;
        } catch (error) {
            return false;
        }
    }

    static renderServers(client) {
        const serversList = document.querySelector('.servers-list');
        if (!serversList) return;

        serversList.innerHTML = '';
        
        if (client.servers.length === 0) {
            serversList.innerHTML = '<div class="no-results">Нет серверов</div>';
            return;
        }
        
        client.servers.forEach(server => {
            const serverElement = document.createElement('div');
            serverElement.className = 'server-item';
            serverElement.dataset.server = server.id;
            
            const isOwner = server.ownerId === client.userId;
            const isMember = server.members && server.members.includes(client.userId);
            
            serverElement.innerHTML = `🏠 ${server.name} ${isOwner ? '<span class="owner-badge">(Вы)</span>' : ''}`;
            
            serverElement.addEventListener('click', () => {
                client.currentServerId = server.id;
                client.currentServer = server;
                
                // Сохраняем выбор сервера
                localStorage.setItem('lastServerId', server.id);
                
                if (client.serverSearchInput) {
                    client.serverSearchInput.value = '';
                }
                
                setTimeout(() => {
                    RoomManager.loadRoomsForServer(client, server.id);
                    client.showPanel('rooms');
                }, 100);
            });
            
            const actionButtons = document.createElement('div');
            actionButtons.className = 'server-actions';
            
            if (isOwner) {
                // Кнопка для создания инвайта
                const inviteBtn = document.createElement('button');
                inviteBtn.className = 'server-action-btn';
                inviteBtn.innerHTML = '🔗';
                inviteBtn.title = 'Создать приглашение';
                inviteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.createServerInvite(client, server.id);
                });
                
                const shareBtn = document.createElement('button');
                shareBtn.className = 'server-action-btn';
                shareBtn.innerHTML = '📋';
                shareBtn.title = 'Скопировать ссылку';
                shareBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.copyServerInviteLink(client, server.id);
                });
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'server-action-btn';
                deleteBtn.innerHTML = '✕';
                deleteBtn.title = 'Удалить';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.deleteServer(client, server.id);
                });
                
                actionButtons.appendChild(inviteBtn);
                actionButtons.appendChild(shareBtn);
                actionButtons.appendChild(deleteBtn);
            } else if (isMember) {
                const leaveBtn = document.createElement('button');
                leaveBtn.className = 'server-action-btn leave-btn';
                leaveBtn.innerHTML = '🚪';
                leaveBtn.title = 'Покинуть сервер';
                leaveBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.leaveServer(client, server.id);
                });
                
                actionButtons.appendChild(leaveBtn);
            }
            
            serverElement.appendChild(actionButtons);
            serversList.appendChild(serverElement);
        });
    }

    static async createServerInvite(client, serverId) {
        try {
            const invite = await InviteManager.createServerInvite(serverId);
            
            if (invite) {
                const inviteLink = InviteManager.generateInviteLink(invite.code);
                
                UIManager.openModal('Приглашение создано', `
                    <p>Приглашение для сервера создано!</p>
                    <div class="invite-link-container">
                        <input type="text" id="inviteLinkInput" value="${inviteLink}" readonly>
                        <button onclick="navigator.clipboard.writeText('${inviteLink}').then(() => alert('Ссылка скопирована!'))">Копировать</button>
                    </div>
                    <p>Ссылка действительна до: ${new Date(invite.expiresAt).toLocaleDateString()}</p>
                `, () => {
                    UIManager.closeModal();
                });
            }
        } catch (error) {
            console.error('Ошибка создания инвайта:', error);
            UIManager.showError('Не удалось создать приглашение: ' + error.message);
        }
    }

    static async copyServerInviteLink(client, serverId) {
        try {
            const invites = await InviteManager.getServerInvites(serverId);
            
            if (invites && invites.length > 0) {
                const activeInvite = invites.find(invite => new Date(invite.expiresAt) > new Date());
                
                if (activeInvite) {
                    InviteManager.copyInviteLink(activeInvite.code);
                    return;
                }
            }
            
            const invite = await InviteManager.createServerInvite(serverId);
            if (invite) {
                InviteManager.copyInviteLink(invite.code);
            }
        } catch (error) {
            console.error('Ошибка копирования ссылки инвайта:', error);
            UIManager.showError('Не удалось скопировать ссылку приглашения');
        }
    }

    static async createServer(client) {
        const name = prompt('Введите название сервера:');
        if (!name || name.length < 3) {
            alert('Название должно быть от 3 символов');
            return;
        }
        
        try {
            const res = await fetch(`${client.API_SERVER_URL}/api/servers`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${client.token}`
                },
                body: JSON.stringify({ 
                    name: name.trim(), 
                    userId: client.userId, 
                    token: client.token 
                })
            });
            
            if (!res.ok) {
                const errorData = await res.json().catch(() => ({}));
                const errorMessage = errorData.error || 'Не удалось создать сервер';
                
                if (errorMessage.includes('уже существует')) {
                    alert(`Ошибка: ${errorMessage}. Выберите другое название.`);
                } else if (errorMessage.includes('Превышен лимит')) {
                    alert(`Ошибка: ${errorMessage}`);
                } else {
                    throw new Error(errorMessage);
                }
                return;
            }
            
            const data = await res.json();
            const serverData = data.server;
            
            client.servers.push(serverData);
            this.saveServersToLocalStorage(client);
            this.renderServers(client);
            client.currentServerId = serverData.id;
            client.currentServer = serverData;
            
            // Сохраняем выбор сервера
            localStorage.setItem('lastServerId', serverData.id);
            
            await RoomManager.loadRoomsForServer(client, client.currentServerId);
            
        } catch (error) {
            alert('Ошибка: ' + error.message);
        }
    }

    static deleteServer(client, serverId) {
        if (!confirm('Вы уверены, что хотите удалить этот сервер? Все комнаты будут удалены.')) return;
        
        const serverIndex = client.servers.findIndex(s => s.id === serverId);
        if (serverIndex !== -1) {
            const serverName = client.servers[serverIndex].name;
            client.servers = client.servers.filter(server => server.id !== serverId);
            this.saveServersToLocalStorage(client);
            this.renderServers(client);
            
            if (client.currentServerId === serverId) {
                client.currentServerId = null;
                client.currentServer = null;
                
                // Очищаем сохраненное состояние
                localStorage.removeItem('lastServerId');
                localStorage.removeItem('lastRoomId');
            }
            
            UIManager.addMessage('System', `✅ Сервер "${serverName}" удален`);
        }
    }

    static async searchServers(client, query) {
        try {
            if (!query || query.length < 2) {
                this.renderServers(client);
                return;
            }

            const res = await fetch(`${client.API_SERVER_URL}/api/servers/search?q=${encodeURIComponent(query)}`, {
                headers: { 
                    'Authorization': `Bearer ${client.token}`,
                    'Content-Type': 'application/json'
                }
            });
            
            if (!res.ok) {
                const errorData = await res.json().catch(() => ({}));
                throw new Error(errorData.error || 'Ошибка поиска');
            }
            
            const data = await res.json();
            this.renderSearchResults(client, data.servers);
        } catch (error) {
            UIManager.showError('Ошибка поиска: ' + error.message);
        }
    }

    static renderSearchResults(client, servers) {
        const serversList = document.querySelector('.servers-list');
        if (!serversList) return;

        serversList.innerHTML = '';
        
        if (servers.length === 0) {
            serversList.innerHTML = '<div class="no-results">Серверы не найдены</div>';
            return;
        }
        
        servers.forEach(server => {
            const serverElement = document.createElement('div');
            serverElement.className = 'server-item';
            serverElement.dataset.server = server.id;
            
            const isOwner = server.ownerId === client.userId;
            const isMember = client.servers.some(s => s.id === server.id);
            
            serverElement.innerHTML = `🏠 ${server.name} ${isOwner ? '<span class="owner-badge">(Вы)</span>' : ''} ${!isMember ? '<span class="not-member-badge">(Не участник)</span>' : ''}`;
            
            if (isMember) {
                serverElement.addEventListener('click', () => {
                    client.currentServerId = server.id;
                    client.currentServer = server;
                    
                    // Сохраняем выбор сервера
                    localStorage.setItem('lastServerId', server.id);
                    
                    if (client.serverSearchInput) {
                        client.serverSearchInput.value = '';
                    }
                    
                    setTimeout(() => {
                        RoomManager.loadRoomsForServer(client, server.id);
                        client.showPanel('rooms');
                    }, 100);
                });
            } else {
                serverElement.style.opacity = '0.7';
                serverElement.style.cursor = 'default';
                
                const joinBtn = document.createElement('button');
                joinBtn.className = 'server-action-btn join-btn';
                joinBtn.innerHTML = '➕';
                joinBtn.title = 'Присоединиться';
                joinBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.joinServer(client, server.id);
                });
                
                serverElement.appendChild(joinBtn);
            }
            
            if (isOwner) {
                const actionButtons = document.createElement('div');
                actionButtons.className = 'server-actions';
                
                const shareBtn = document.createElement('button');
                shareBtn.className = 'server-action-btn';
                shareBtn.innerHTML = '🔗';
                shareBtn.title = 'Пригласить';
                shareBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.copyServerInviteLink(client, server.id);
                });
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'server-action-btn';
                deleteBtn.innerHTML = '✕';
                deleteBtn.title = 'Удалить';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.deleteServer(client, server.id);
                });
                
                actionButtons.appendChild(shareBtn);
                actionButtons.appendChild(deleteBtn);
                serverElement.appendChild(actionButtons);
            }
            
            serversList.appendChild(serverElement);
        });
    }

    static async joinServer(client, serverId) {
        try {
            const res = await fetch(`${client.API_SERVER_URL}/api/servers/${serverId}/join`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${client.token}`
                },
                body: JSON.stringify({ userId: client.userId, token: client.token })
            });

            if (!res.ok) {
                const err = await res.json().catch(() => ({}));
                throw new Error(err.error || 'Не удалось присоединиться');
            }

            const data = await res.json();
            const server = data.server;

            const exists = client.servers.some(s => s.id === server.id);
            if (!exists) {
                client.servers.push(server);
                this.saveServersToLocalStorage(client);
            }

            if (client.serverSearchInput) {
                client.serverSearchInput.value = '';
            }

            // Сохраняем выбор сервера
            localStorage.setItem('lastServerId', server.id);
            
            this.renderServers(client);
            client.showPanel('servers');
            
            UIManager.addMessage('System', `✅ Вы присоединились к "${server.name}"`);

        } catch (error) {
            UIManager.showError(`❌ Не удалось присоединиться: ${error.message}`);
        }
    }

    static async leaveServer(client, serverId) {
        if (!confirm('Вы уверены, что хотите покинуть этот сервер?')) return;
        
        try {
            const res = await fetch(`${client.API_SERVER_URL}/api/servers/${serverId}/leave`, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${client.token}`,
                    'Content-Type': 'application/json'
                }
            });
            
            if (!res.ok) {
                const errorData = await res.json().catch(() => ({}));
                throw new Error(errorData.error || 'Не удалось покинуть сервер');
            }
            
            client.servers = client.servers.filter(server => server.id !== serverId);
            this.saveServersToLocalStorage(client);
            
            // Очищаем сохраненное состояние, если выходим с текущего сервера
            if (client.currentServerId === serverId) {
                client.currentServerId = null;
                client.currentServer = null;
                client.currentRoom = null;
                
                localStorage.removeItem('lastServerId');
                localStorage.removeItem('lastRoomId');
            }
            
            this.renderServers(client);
            
            UIManager.addMessage('System', `✅ Вы покинули сервер`);
            
        } catch (error) {
            UIManager.showError('Ошибка: ' + error.message);
        }
    }

    static clearSearchAndShowAllServers(client) {
        if (client.serverSearchInput) {
            client.serverSearchInput.value = '';
        }
        
        this.renderServers(client);
    }
}

export default ServerManager;


modules/TextChatManager.js:
import UIManager from './UIManager.js';

class TextChatManager {
    static setupSocketHandlers(client) {
        if (!client.socket) return;

        client.socket.on('new-message', (message) => {
            console.log('New message received:', message);
            if (message.roomId === client.currentRoom) {
                UIManager.addMessage(message.username, message.text, message.timestamp);
            }
        });

        client.socket.on('text-message-history', (data) => {
            console.log('Message history received:', data);
            if (data.roomId === client.currentRoom && data.messages) {
                UIManager.clearMessages();
                
                data.messages.forEach(msg => {
                    UIManager.addMessage(msg.username, msg.text, msg.timestamp);
                });
            }
        });

        client.socket.on('connect', () => {
            console.log('Socket connected');
            UIManager.updateStatus('Подключено', 'connected');
            
            if (client.currentRoom) {
                this.joinTextRoom(client, client.currentRoom);
            }
        });

        client.socket.on('disconnect', (reason) => {
            console.log('Socket disconnected:', reason);
            UIManager.updateStatus('Отключено', 'disconnected');
        });
    }

    static joinTextRoom(client, roomId) {
        if (client.socket) {
            client.socket.emit('join-text-room', { roomId });
        }
    }

    static leaveTextRoom(client, roomId) {
        if (client.socket) {
            client.socket.emit('leave-text-room', { roomId });
        }
    }

    static async loadMoreMessages(client, roomId, beforeMessageId) {
        return this.loadMessages(client, roomId, 50, beforeMessageId);
    }

    static async loadMessages(client, roomId, limit = 100, before = null) {
        try {
            const params = new URLSearchParams();
            params.append('limit', limit);
            if (before) params.append('before', before);
            
            const response = await fetch(`${client.API_SERVER_URL}/api/chat/rooms/${roomId}/messages?${params}`, {
                headers: {
                    'Authorization': `Bearer ${client.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.ok) {
                const data = await response.json();
                if (data.messages && Array.isArray(data.messages)) {
                    if (!before) {
                        UIManager.clearMessages();
                    }
                    
                    data.messages.forEach(message => {
                        UIManager.addMessage(message.username, message.text, message.timestamp);
                    });
                }
            }
        } catch (error) {
            console.error('Error loading messages:', error);
        }
    }

    static async sendMessage(client, text) {
        if (!text.trim() || !client.currentRoom) return;

        try {
            const response = await fetch(`${client.API_SERVER_URL}/api/chat/messages`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${client.token}`
                },
                body: JSON.stringify({
                    roomId: client.currentRoom,
                    text: text.trim()
                })
            });

            if (!response.ok) {
                throw new Error('Ошибка отправки сообщения');
            }
            
            const data = await response.json();
            return data.message;
        } catch (error) {
            UIManager.showError('Не удалось отправить сообщение');
            throw error;
        }
    }
}

export default TextChatManager;


modules/UIManager.js:
import MembersManager from './MembersManager.js';

class UIManager {
    static client = null;

    static setClient(client) {
        this.client = client;
    }

    static updateStatus(text, status) {
        const statusText = document.querySelector('.status-text');
        const statusIndicator = document.querySelector('.status-indicator');
        
        if (statusText) {
            statusText.textContent = text;
        }
        if (statusIndicator) {
            statusIndicator.className = 'status-indicator';
            if (status === 'connecting') {
                statusIndicator.classList.add('connecting');
            } else if (status === 'disconnected') {
                statusIndicator.classList.add('disconnected');
            } else if (status === 'connected') {
                statusIndicator.classList.add('connected');
            }
        }
    }

    static openCreateRoomModal(client, onSubmit) {
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'modal-overlay';
        modalOverlay.style.display = 'flex';
        modalOverlay.innerHTML = `
            <div class="modal-content">
                <h2>Создание комнаты</h2>
                <input type="text" id="roomNameInput" placeholder="Название комнаты" required>
                <div class="modal-buttons">
                    <button id="confirmCreateRoom">Создать</button>
                    <button id="cancelCreateRoom">Отмена</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modalOverlay);

        const handleConfirm = () => {
            const name = document.getElementById('roomNameInput').value.trim();
            
            if (name.length < 3) {
                alert('Название комнаты должно быть не менее 3 символов');
                return;
            }
            
            modalOverlay.remove();
            onSubmit(name);
        };

        const handleCancel = () => {
            modalOverlay.remove();
        };

        modalOverlay.querySelector('#confirmCreateRoom').addEventListener('click', handleConfirm);
        modalOverlay.querySelector('#cancelCreateRoom').addEventListener('click', handleCancel);
        
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                handleCancel();
            }
        });
    }
    
    static updateRoomTitle(title) {
        const titleElement = document.querySelector('.current-room-title');
        if (titleElement) {
            titleElement.textContent = title;
        }
    }

    static addMessage(user, text, timestamp = null) {
        const messagesContainer = document.querySelector('.messages-container');
        if (!messagesContainer) return;

        const safeUser = user || 'Unknown';
        const safeText = text || '';

        const messageElement = document.createElement('div');
        messageElement.className = 'message';
        
        const time = timestamp ? 
            new Date(timestamp).toLocaleTimeString('ru-RU', {
                hour: '2-digit',
                minute: '2-digit'
            }) : 
            new Date().toLocaleTimeString('ru-RU', {
                hour: '2-digit',
                minute: '2-digit'
            });
        
        messageElement.innerHTML = `
            <div class="message-avatar">${safeUser.charAt(0).toUpperCase()}</div>
            <div class="message-content">
                <div class="message-header">
                    <span class="message-username">${this.escapeHtml(safeUser)}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="message-text">${this.escapeHtml(safeText)}</div>
            </div>
        `;
        
        messagesContainer.appendChild(messageElement);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
        setTimeout(() => {
            messageElement.classList.add('appeared');
        }, 10);
    }

    static updateMicButton(status) {
        const micButton = document.querySelector('.mic-button');
        const micToggleBtn = document.querySelector('.mic-toggle-btn');
        
        const states = {
            'disconnected': {class: 'disconnected', text: '🎤', title: 'Не подключен к голосовому каналу'},
            'connecting': {class: 'connecting', text: '🎤', title: 'Подключение...'},
            'connected': {class: 'connected', text: '🎤', title: 'Микрофон выключен (нажмите чтобы включить)'},
            'active': {class: 'active', text: '🔴', title: 'Микрофон включен (нажмите чтобы выключить)'},
            'error': {class: 'error', text: '🎤', title: 'Ошибка доступа к микрофону'}
        };
        
        const state = states[status] || states.disconnected;
        
        if (micButton) {
            micButton.className = 'mic-button ' + state.class;
            micButton.textContent = state.text;
            micButton.title = state.title;
        }
        
        if (micToggleBtn) {
            micToggleBtn.className = 'mic-toggle-btn ' + state.class;
            micToggleBtn.textContent = state.text;
            micToggleBtn.title = state.title;
        }
    }

    static updateAudioStatus(activeConsumers) {
        const statusElement = document.querySelector('.audio-status');
        if (!statusElement) return;
        
        if (activeConsumers > 0) {
            statusElement.textContent = `Активных аудиопотоков: ${activeConsumers}`;
            statusElement.style.color = 'var(--success)';
        } else {
            statusElement.textContent = 'Нет активных аудиопотоков';
            statusElement.style.color = 'var(--text-muted)';
        }
    }

    static renderServers(client) {
        const serversList = document.querySelector('.servers-list');
        if (!serversList) return;

        serversList.innerHTML = '';
        
        client.servers.forEach(server => {
            const serverElement = document.createElement('div');
            serverElement.className = 'server-item';
            serverElement.dataset.server = server.id;
            
            const isOwner = server.ownerId === client.userId;
            serverElement.innerHTML = `🏠 ${server.name} ${isOwner ? '<span class="owner-badge">(Вы)</span>' : ''}`;
            
            serverElement.addEventListener('click', () => {
                client.currentServerId = server.id;
                client.currentServer = server;
                import('./RoomManager.js').then(module => {
                    module.default.loadRoomsForServer(client, server.id);
                });
                client.showPanel('rooms');
            });
            
            if (isOwner) {
                const shareBtn = document.createElement('button');
                shareBtn.className = 'server-action-btn';
                shareBtn.innerHTML = '🔗';
                shareBtn.title = 'Пригласить';
                shareBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const inviteLink = `${window.location.origin}${window.location.pathname}?invite=${server.id}`;
                    navigator.clipboard.writeText(inviteLink)
                        .then(() => alert(`Ссылка скопирована: ${inviteLink}`))
                        .catch(() => {});
                });
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'server-action-btn';
                deleteBtn.innerHTML = '✕';
                deleteBtn.title = 'Удалить';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    import('./ServerManager.js').then(module => {
                        module.default.deleteServer(client, server.id);
                    });
                });
                
                serverElement.appendChild(shareBtn);
                serverElement.appendChild(deleteBtn);
            }
            
            serversList.appendChild(serverElement);
        });
    }

    static renderRooms(client, rooms) {
        const roomsList = document.querySelector('.rooms-list');
        if (!roomsList) return;

        roomsList.innerHTML = '';
        
        rooms.forEach(room => {
            const roomElement = document.createElement('div');
            roomElement.className = 'room-item';
            roomElement.dataset.room = room.id;
            
            const isOwner = room.ownerId === client.userId;
            roomElement.innerHTML = `🔊 ${room.name} ${isOwner ? '<span class="owner-badge">(Вы)</span>' : ''}`;
            
            roomElement.addEventListener('click', () => {
                client.currentRoom = room.id;
                client.joinRoom(room.id);
            });
            
            roomsList.appendChild(roomElement);
        });
    }

    static updateMembersList(members) {
        const membersList = document.querySelector('.members-list');
        if (!membersList) return;

        membersList.innerHTML = '';
        
        if (this.client && this.client.username) {
            const selfElement = document.createElement('div');
            selfElement.className = 'member-item';
            const selfUsername = this.client.username || 'Вы';
            selfElement.innerHTML = `
                <div class="member-avatar">${selfUsername.charAt(0).toUpperCase()}</div>
                <div class="member-name">${selfUsername}</div>
                <div class="member-status">
                    <div class="status-indicator online" title="Online"></div>
                    <div class="mic-indicator ${this.client.isMicActive ? 'active' : ''}" title="${this.client.isMicActive ? 'Microphone active' : 'Microphone muted'}"></div>
                </div>
            `;
            membersList.appendChild(selfElement);
        }
        
        members.forEach(user => {
            if (user.userId === this.client.userId) return;
            
            const memberElement = document.createElement('div');
            memberElement.className = 'member-item';
            memberElement.dataset.userId = user.userId;
            memberElement.innerHTML = `
                <div class="member-avatar">${user.username.charAt(0).toUpperCase()}</div>
                <div class="member-name">${user.username}</div>
                <div class="member-status">
                    <div class="status-indicator online" title="Online"></div>
                    <div class="mic-indicator ${user.isMicActive ? 'active' : ''}" title="${user.isMicActive ? 'Microphone active' : 'Microphone muted'}"></div>
                </div>
            `;
            membersList.appendChild(memberElement);
        });
    }

    static updateMemberMicState(userId, isActive) {
        const memberElement = document.querySelector(`.member-item[data-user-id="${userId}"]`);
        if (memberElement) {
            const micIndicator = memberElement.querySelector('.mic-indicator');
            if (micIndicator) {
                micIndicator.className = isActive ? 'mic-indicator active' : 'mic-indicator';
                micIndicator.title = isActive ? 'Microphone active' : 'Microphone muted';
            }
        }
    }

    static openModal(title, content, onSubmit) {
        const modalOverlay = document.querySelector('.modal-overlay');
        const modalContent = document.querySelector('.modal-content');
        
        if (!modalOverlay || !modalContent) return;
        
        modalContent.innerHTML = `
            <h2>${title}</h2>
            ${content}
            <button class="modal-submit">OK</button>
        `;
        
        modalOverlay.classList.remove('hidden');
        
        const submitButton = modalContent.querySelector('.modal-submit');
        if (submitButton && onSubmit) {
            submitButton.addEventListener('click', onSubmit);
        }
    }

    static closeModal() {
        const modalOverlay = document.querySelector('.modal-overlay');
        if (modalOverlay) modalOverlay.classList.add('hidden');
    }

    static showError(message) {
        const errorElement = document.createElement('div');
        errorElement.className = 'error-message';
        errorElement.textContent = message;
        errorElement.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ed4245;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 1000;
            max-width: 300px;
        `;
        
        document.body.appendChild(errorElement);
        
        setTimeout(() => {
            if (document.body.contains(errorElement)) {
                document.body.removeChild(errorElement);
            }
        }, 5000);
    }

    static escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    static openSettings(client) {
        const modalContent = `
            <h2>Настройки</h2>
            <div class="setting-item">
                <label>Битрейт: <span id="bitrateValue">${client.bitrate / 1000}</span> kbps</label>
                <input type="range" id="bitrateSlider" min="16" max="64" value="${client.bitrate / 1000}" step="1">
            </div>
            <div class="setting-item">
                <label>
                    <input type="checkbox" id="dtxCheckbox" ${client.dtxEnabled ? 'checked' : ''}>
                    DTX (Discontinuous Transmission)
                </label>
            </div>
            <div class="setting-item">
                <label>
                    <input type="checkbox" id="fecCheckbox" ${client.fecEnabled ? 'checked' : ''}>
                    FEC (Forward Error Correction)
                </label>
            </div>
            <button class="apply-settings-btn">Применить</button>
        `;
        
        this.openModal('Настройки', modalContent, () => {
            client.bitrate = document.getElementById('bitrateSlider').value * 1000;
            client.dtxEnabled = document.getElementById('dtxCheckbox').checked;
            client.fecEnabled = document.getElementById('fecCheckbox').checked;
            this.closeModal();
        });
        
        const bitrateSlider = document.getElementById('bitrateSlider');
        const bitrateValue = document.getElementById('bitrateValue');
        
        if (bitrateSlider && bitrateValue) {
            bitrateSlider.addEventListener('input', () => {
                bitrateValue.textContent = bitrateSlider.value;
            });
        }
    }

    static onRoomJoined(client, roomName) {
        this.updateRoomTitle(roomName);
        this.updateStatus('Подключено', 'connected');
    }

    static openPanel(client, panel) {
        if (!panel) return;
        panel.style.display = 'flex';
        setTimeout(() => {
            panel.style.opacity = '1';
            panel.style.transform = 'translateX(0)';
        }, 10);
    }

    static closePanel(client, panel) {
        if (!panel) return;
        panel.style.opacity = '0';
        panel.style.transform = 'translateX(-100%)';
        setTimeout(() => {
            panel.style.display = 'none';
        }, 300);
    }

    static toggleSidebar() {
        const sidebar = document.querySelector('.sidebar');
        sidebar.classList.toggle('open');
    }

    static toggleMembersPanel(client) {
        const membersPanel = document.querySelector('.members-panel');
        membersPanel.classList.toggle('open');
    }

    static applySettings(client) {
        client.bitrate = document.getElementById('bitrateSlider').value * 1000;
        client.dtxEnabled = document.getElementById('dtxCheckbox').checked;
        client.fecEnabled = document.getElementById('fecCheckbox').checked;
        this.closeModal();
    }

    static updateRoomUI(client) {
        const messagesContainer = document.querySelector('.messages-container');
        if (messagesContainer) {
            messagesContainer.innerHTML = '';
        }
        
        this.updateRoomTitle(client.currentRoom ? `Комната: ${client.currentRoom}` : 'Выберите комнату');
        
        this.updateMicButton(client.isConnected ? (client.isMicActive ? 'active' : 'connected') : 'disconnected');
    }

    static clearMessages() {
        const messagesContainer = document.querySelector('.messages-container');
        if (messagesContainer) {
            messagesContainer.innerHTML = '';
        }
    }
}

export default UIManager;


modules/UserPresenceManager.js:
import UIManager from './UIManager.js';

class UserPresenceManager {
    static PRESENCE_UPDATE_INTERVAL = 30000; // 30 секунд
    static INACTIVITY_TIMEOUT = 300000; // 5 минут

    static init(client) {
        this.client = client;
        this.lastActivityTime = Date.now();
        this.setupActivityTracking();
        this.startPresenceUpdates();
    }

    static setupActivityTracking() {
        // Отслеживаем активность пользователя
        const activityEvents = [
            'mousedown', 'mousemove', 'keypress', 
            'scroll', 'touchstart', 'click',
            'message', 'mic-state-change'
        ];

        activityEvents.forEach(event => {
            document.addEventListener(event, () => {
                this.updateLastActivity();
            }, { passive: true });
        });

        // Также отслеживаем активность в чате
        const originalAddMessage = UIManager.addMessage;
        UIManager.addMessage = function(...args) {
            originalAddMessage.apply(this, args);
            UserPresenceManager.updateLastActivity();
        };
    }

    static updateLastActivity() {
        this.lastActivityTime = Date.now();
        
        // Если пользователь стал активным после периода неактивности
        if (!this.isUserActive && this.client.userId) {
            this.setUserActive(true);
        }
    }

    static async setUserActive(isActive) {
        if (!this.client.userId || !this.client.token) return;

        this.isUserActive = isActive;

        try {
            // Используем существующий эндпоинт для обновления присутствия
            const response = await fetch(`${this.client.API_SERVER_URL}/api/presence/update`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.client.token}`
                },
                body: JSON.stringify({
                    isOnline: isActive,
                    currentRoom: this.client.currentRoom,
                    lastActivity: new Date().toISOString()
                })
            });

            if (!response.ok) {
                throw new Error('Ошибка обновления статуса');
            }
        } catch (error) {
            console.error('Ошибка обновления статуса присутствия:', error);
        }
    }

    static startPresenceUpdates() {
        // Периодически обновляем статус присутствия
        this.presenceInterval = setInterval(() => {
            this.checkActivity();
            this.updatePresence();
        }, this.PRESENCE_UPDATE_INTERVAL);

        // Также обновляем статус при изменении комнаты
        const originalJoinRoom = this.client.joinRoom;
        this.client.joinRoom = async (...args) => {
            const result = await originalJoinRoom.apply(this.client, args);
            if (result) {
                this.updatePresence();
            }
            return result;
        };

        const originalLeaveRoom = this.client.leaveRoom;
        this.client.leaveRoom = async (...args) => {
            const result = await originalLeaveRoom.apply(this.client, args);
            if (result) {
                this.updatePresence();
            }
            return result;
        };
    }

    static checkActivity() {
        const currentTime = Date.now();
        const inactiveTime = currentTime - this.lastActivityTime;

        // Если пользователь неактивен дольше таймаута
        if (inactiveTime > this.INACTIVITY_TIMEOUT && this.isUserActive) {
            this.setUserActive(false);
        }
        // Если пользователь снова активен после неактивности
        else if (inactiveTime <= this.INACTIVITY_TIMEOUT && !this.isUserActive) {
            this.setUserActive(true);
        }
    }

    static async updatePresence() {
        if (!this.client.userId || !this.client.token) return;

        try {
            const response = await fetch(`${this.client.API_SERVER_URL}/api/presence/update`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.client.token}`
                },
                body: JSON.stringify({
                    currentRoom: this.client.currentRoom,
                    isMicActive: this.client.isMicActive,
                    lastActivity: new Date().toISOString()
                })
            });

            if (!response.ok) {
                throw new Error('Ошибка обновления присутствия');
            }
        } catch (error) {
            console.error('Ошибка обновления присутствия:', error);
        }
    }

    static async getOnlineUsers(roomId = null) {
        if (!this.client.token) return [];

        try {
            let url = `${this.client.API_SERVER_URL}/api/presence/online-users`;
            if (roomId) {
                url += `?roomId=${roomId}`;
            }

            const response = await fetch(url, {
                headers: {
                    'Authorization': `Bearer ${this.client.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error('Ошибка получения онлайн пользователей');
            }

            const data = await response.json();
            return data.users || [];
        } catch (error) {
            console.error('Ошибка получения онлайн пользователей:', error);
            return [];
        }
    }

    static async getUserPresence(userId) {
        if (!this.client.token) return { isOnline: false, lastSeen: null };

        try {
            const response = await fetch(`${this.client.API_SERVER_URL}/api/presence/user/${userId}`, {
                headers: {
                    'Authorization': `Bearer ${this.client.token}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error('Ошибка получения статуса пользователя');
            }

            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Ошибка получения статуса пользователя:', error);
            return { isOnline: false, lastSeen: null };
        }
    }

    static async subscribeToPresenceUpdates(roomId) {
        if (!this.client.socket || !roomId) return;

        // Подписываемся на обновления присутствия через сокет
        this.client.socket.emit('subscribe-presence', { roomId });

        this.client.socket.on('presence-update', (data) => {
            this.handlePresenceUpdate(data);
        });

        this.client.socket.on('user-joined', (data) => {
            this.handleUserJoined(data);
        });

        this.client.socket.on('user-left', (data) => {
            this.handleUserLeft(data);
        });
    }

    static handlePresenceUpdate(data) {
        // Обрабатываем обновление статуса пользователя
        const { userId, isOnline, isMicActive, lastSeen } = data;
        
        // Обновляем UI
        UIManager.updateUserPresence(userId, {
            isOnline,
            isMicActive,
            lastSeen: lastSeen ? new Date(lastSeen) : null
        });
    }

    static handleUserJoined(data) {
        // Обрабатываем присоединение пользователя
        const { userId, username, isMicActive } = data;
        
        // Добавляем пользователя в UI
        UIManager.addUser({
            userId,
            username,
            isMicActive: isMicActive || false,
            isOnline: true
        });

        // Показываем системное сообщение
        UIManager.addMessage('System', `Пользователь ${username} присоединился`, new Date().toISOString());
    }

    static handleUserLeft(data) {
        // Обрабатываем выход пользователя
        const { userId, username } = data;
        
        // Обновляем статус пользователя в UI
        UIManager.updateUserPresence(userId, {
            isOnline: false,
            isMicActive: false,
            lastSeen: new Date().toISOString()
        });

        // Показываем системное сообщение
        UIManager.addMessage('System', `Пользователь ${username} покинул чат`, new Date().toISOString());
    }

    static async updateMicState(isActive) {
        if (!this.client.userId || !this.client.token) return;

        this.client.isMicActive = isActive;

        try {
            const response = await fetch(`${this.client.API_SERVER_URL}/api/presence/mic-state`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.client.token}`
                },
                body: JSON.stringify({
                    isActive: isActive,
                    roomId: this.client.currentRoom
                })
            });

            if (!response.ok) {
                throw new Error('Ошибка обновления статуса микрофона');
            }

            // Также отправляем через сокет для мгновенного обновления
            if (this.client.socket && this.client.currentRoom) {
                this.client.socket.emit('mic-state-change', {
                    isActive: isActive,
                    roomId: this.client.currentRoom
                });
            }
        } catch (error) {
            console.error('Ошибка обновления статуса микрофона:', error);
        }
    }

    static cleanup() {
        if (this.presenceInterval) {
            clearInterval(this.presenceInterval);
        }

        // Устанавливаем статус оффлайн при выходе
        if (this.client.userId) {
            this.setUserActive(false);
        }
    }
}

export default UserPresenceManager;


modules/Utils.js:
class Utils {
    static generateClientID() {
        return 'client_' + Math.random().toString(36).substr(2, 9);
    }

    static escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }

    static debounce(func, wait, immediate = false) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                if (!immediate) func(...args);
            };
            const callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func(...args);
        };
    }

    static throttle(func, limit) {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }

    static formatTime(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleTimeString('ru-RU', {
            hour: '2-digit',
            minute: '2-digit'
        });
    }

    static generateRandomString(length = 8) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < length; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }

    static isValidEmail(email) {
        const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return re.test(email);
    }

    static copyToClipboard(text) {
        return new Promise((resolve, reject) => {
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(text)
                    .then(resolve)
                    .catch(reject);
            } else {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    resolve();
                } catch (err) {
                    reject(err);
                }
                document.body.removeChild(textArea);
            }
        });
    }

    static formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    static async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    static isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    static getOS() {
        const userAgent = navigator.userAgent;
        if (/Windows/.test(userAgent)) return 'Windows';
        if (/Mac/.test(userAgent)) return 'MacOS';
        if (/Linux/.test(userAgent)) return 'Linux';
        if (/Android/.test(userAgent)) return 'Android';
        if (/iOS|iPhone|iPad|iPod/.test(userAgent)) return 'iOS';
        return 'Unknown';
    }

    static getBrowser() {
        const userAgent = navigator.userAgent;
        if (/Edg/.test(userAgent)) return 'Edge';
        if (/Chrome/.test(userAgent)) return 'Chrome';
        if (/Firefox/.test(userAgent)) return 'Firefox';
        if (/Safari/.test(userAgent)) return 'Safari';
        if (/Opera|OPR/.test(userAgent)) return 'Opera';
        return 'Unknown';
    }

    static sanitizeInput(input) {
        const div = document.createElement('div');
        div.textContent = input;
        return div.innerHTML;
    }

    static parseJWT(token) {
        try {
            const base64Url = token.split('.')[1];
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
            return JSON.parse(jsonPayload);
        } catch (e) {
            return null;
        }
    }

    static isJWTExpired(token) {
        const payload = this.parseJWT(token);
        if (!payload || !payload.exp) return true;
        return Date.now() >= payload.exp * 1000;
    }

    static arrayToObject(array, keyField, valueField = null) {
        return array.reduce((obj, item) => {
            obj[item[keyField]] = valueField ? item[valueField] : item;
            return obj;
        }, {});
    }

    static deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }

    static mergeObjects(...objects) {
        return objects.reduce((merged, obj) => {
            return { ...merged, ...obj };
        }, {});
    }

    static capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    static truncateString(str, maxLength, suffix = '...') {
        if (str.length <= maxLength) return str;
        return str.substring(0, maxLength) + suffix;
    }

    static isElementInViewport(el) {
        const rect = el.getBoundingClientRect();
        return (
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth)
        );
    }

    static scrollToElement(element, behavior = 'smooth') {
        element.scrollIntoView({ behavior, block: 'nearest' });
    }

    static formatNumber(number, decimals = 0) {
        return new Intl.NumberFormat('ru-RU', {
            minimumFractionDigits: decimals,
            maximumFractionDigits: decimals
        }).format(number);
    }

    static formatCurrency(amount, currency = 'RUB') {
        return new Intl.NumberFormat('ru-RU', {
            style: 'currency',
            currency: currency
        }).format(amount);
    }

    static getQueryParams() {
        const params = {};
        const queryString = window.location.search.substring(1);
        const pairs = queryString.split('&');
        
        for (const pair of pairs) {
            const [key, value] = pair.split('=');
            if (key) {
                params[decodeURIComponent(key)] = decodeURIComponent(value || '');
            }
        }
        
        return params;
    }

    static setQueryParams(params) {
        const searchParams = new URLSearchParams();
        
        for (const key in params) {
            if (params[key] !== undefined && params[key] !== null) {
                searchParams.set(key, params[key]);
            }
        }
        
        const newUrl = `${window.location.pathname}?${searchParams.toString()}`;
        window.history.replaceState({}, '', newUrl);
    }
}

export default Utils;


modules/VoiceChatClient.js:
import MediaManager from './MediaManager.js';
import RoomManager from './RoomManager.js';
import ServerManager from './ServerManager.js';
import UIManager from './UIManager.js';
import Utils from './Utils.js';
import TextChatManager from './TextChatManager.js';
import UserPresenceManager from './UserPresenceManager.js';
import InviteManager from './InviteManager.js';
import MembersManager from './MembersManager.js';
import AuthManager from './AuthManager.js';

class VoiceChatClient {
    constructor() {
        this.API_SERVER_URL = 'https://ns.fiber-gate.ru';
        this.CHAT_API_URL = `${this.API_SERVER_URL}/api/join`;
        this.clientID = Utils.generateClientID();
        this.device = null;
        this.sendTransport = null;
        this.recvTransport = null;
        this.audioProducer = null;
        this.consumers = new Map();
        this.existingProducers = new Set();
        this.stream = null;
        this.isMicActive = false;
        this.currentRoom = null;
        this.currentServerId = null;
        this.currentServer = null;
        this.servers = [];
        this.rooms = [];
        this.keepAliveInterval = null;
        this.bitrate = 32000;
        this.dtxEnabled = true;
        this.fecEnabled = true;
        this.isConnected = false;
        this.mediaData = null;
        this.userId = null;
        this.token = null;
        this.username = null;
        this.syncInterval = null;
        this.activePanel = 'servers';
        this.inviteServerId = null;
        this.isCreatingRoom = false;
        this.socket = null;
        this.sseConnection = null;
        this.wasMicActiveBeforeReconnect = false;
        this.isReconnecting = false;
        this.pendingInviteCode = null;
        UIManager.setClient(this);
        this.useHttpPolling = false;

        this.elements = {};
        this.debouncedSync = Utils.debounce(() => this.startConsuming(), 1000);

        this.init();
    }

    async init() {
        console.log('VoiceChatClient initializing...');
        this.initElements();
        this.initEventListeners();
        
        UserPresenceManager.init(this);
        InviteManager.init(this);
        
        await this.initAutoConnect();
    }

    initElements() {
        console.log('Initializing UI elements...');
        
        this.elements.micButton = document.querySelector('.mic-button');
        this.elements.micToggleBtn = document.querySelector('.mic-toggle-btn');
        this.elements.messageInput = document.querySelector('.message-input');
        this.elements.sendButton = document.querySelector('.send-btn');
        this.elements.currentRoomTitle = document.querySelector('.current-room-title');
        this.elements.toggleSidebarBtn = document.querySelector('.toggle-sidebar-btn');
        this.elements.toggleMembersBtn = document.querySelector('.toggle-members-btn');
        this.elements.settingsBtn = document.querySelector('.settings-btn');
        this.elements.closePanelBtn = document.querySelector('.close-panel-btn');
        this.elements.closeSidebarBtn = document.querySelector('.close-sidebar-btn');
        this.elements.createServerBtn = document.querySelector('.create-server-btn');
        this.elements.createRoomBtn = document.querySelector('.create-room-btn');
        this.elements.serversToggleBtn = document.querySelector('#serversToggle');
        this.elements.roomsToggleBtn = document.querySelector('#roomsToggle');
        this.elements.serversList = document.querySelector('.servers-list');
        this.elements.roomsList = document.querySelector('.rooms-list');
        this.elements.membersList = document.querySelector('.members-list');
        this.elements.messagesContainer = document.querySelector('.messages-container');
        this.elements.serversPanel = document.getElementById('servers-panel'); 
        this.elements.roomsPanel = document.getElementById('rooms-panel'); 
        this.elements.sidebar = document.querySelector('.sidebar');
        this.elements.membersPanel = document.querySelector('.members-panel');
        this.elements.serverSearchInput = document.querySelector('#serverSearch');
        this.elements.clearSearchBtn = document.querySelector('#clearSearchBtn');    
        
        if (this.elements.clearSearchBtn) {
            this.elements.clearSearchBtn.addEventListener('click', () => {
                ServerManager.clearSearchAndShowAllServers(this);
            });
        } else {
            console.warn('Clear search button not found');
        }
    }

    initEventListeners() {
        console.log('Setting up event listeners...');
        
        if (this.elements.micButton) {
            this.elements.micButton.addEventListener('click', () => this.toggleMicrophone());
        }
        
        if (this.elements.micToggleBtn) {
            this.elements.micToggleBtn.addEventListener('click', () => this.toggleMicrophone());
        }
        
        if (this.elements.messageInput) {
            this.elements.messageInput.addEventListener('keypress', e => {
                if (e.key === 'Enter') {
                    this.sendMessage(this.elements.messageInput.value);
                    this.elements.messageInput.value = '';
                }
            });
        }
        
        if (this.elements.sendButton) {
            this.elements.sendButton.addEventListener('click', () => {
                this.sendMessage(this.elements.messageInput.value);
                this.elements.messageInput.value = '';
            });
        }
        
        if (this.elements.toggleSidebarBtn) {
            this.elements.toggleSidebarBtn.addEventListener('click', () => {
                this.elements.sidebar.classList.toggle('open');
            });
        }
        
        if (this.elements.toggleMembersBtn) {
            this.elements.toggleMembersBtn.addEventListener('click', () => {
                this.elements.membersPanel.classList.toggle('open');
            });
        }
        
        if (this.elements.closePanelBtn) {
            this.elements.closePanelBtn.addEventListener('click', () => {
                this.elements.membersPanel.classList.remove('open');
            });
        }
        
        if (this.elements.closeSidebarBtn) {
            this.elements.closeSidebarBtn.addEventListener('click', () => {
                this.elements.sidebar.classList.remove('open');
            });
        }
        
        if (this.elements.settingsBtn) {
            this.elements.settingsBtn.addEventListener('click', () => {
                UIManager.openSettings(this);
            });
        }
        
        if (this.elements.createServerBtn) {
            this.elements.createServerBtn.addEventListener('click', () => {
                ServerManager.createServer(this);
            });
        }

        if (this.elements.createRoomBtn) {
            this.elements.createRoomBtn.addEventListener('click', () => {
                if (!this.currentServerId) {
                    alert('Сначала выберите сервер');
                    return;
                }
                
                UIManager.openCreateRoomModal(this, (name) => {
                    RoomManager.createRoom(this, this.currentServerId, name);
                });
            });
        }

        if (this.elements.serversToggleBtn) {
            this.elements.serversToggleBtn.addEventListener('click', () => {
                ServerManager.clearSearchAndShowAllServers(this);
                this.showPanel('servers');
            });
        }
        
        if (this.elements.roomsToggleBtn) {
            this.elements.roomsToggleBtn.addEventListener('click', () => {
                this.showPanel('rooms');
            });
        }
        
        if (this.elements.serverSearchInput) {
            this.elements.serverSearchInput.addEventListener('input', (e) => {
                this.searchServers(e.target.value);
            });
        }
    }

    showPanel(panelName) {
        console.log('Showing panel:', panelName);
        
        const serversPanel = this.elements.serversPanel;
        const roomsPanel = this.elements.roomsPanel;
        const serversToggleBtn = this.elements.serversToggleBtn;
        const roomsToggleBtn = this.elements.roomsToggleBtn;
    
        if (!serversPanel || !roomsPanel || !serversToggleBtn || !roomsToggleBtn) {
            console.error('Required panel elements not found');
            return;
        }
    
        this.activePanel = panelName;
    
        if (panelName === 'servers') {
            serversToggleBtn.classList.add('active');
            roomsToggleBtn.classList.remove('active');
            serversPanel.classList.add('active');
            roomsPanel.classList.remove('active');
        } else {
            serversToggleBtn.classList.remove('active');
            roomsToggleBtn.classList.add('active');
            serversPanel.classList.remove('active');
            roomsPanel.classList.add('active');
        }
    }

    processUrlParams() {
        console.log('Processing URL parameters...');
        const params = new URLSearchParams(window.location.search);
        this.currentServerId = params.get('server');
        this.currentRoom = params.get('room');
        this.inviteServerId = params.get('invite');
        
        const inviteCode = params.get('invite');
        if (inviteCode && /^[a-zA-Z0-9]{4}$/.test(inviteCode)) {
            this.pendingInviteCode = inviteCode;
            console.log('Found pending invite code:', inviteCode);
        }
        
        console.log('URL params processed - server:', this.currentServerId, 'room:', this.currentRoom, 'invite:', this.inviteServerId);
    }

    async initAutoConnect() {
        console.log('Starting auto-connect process...');
        this.processUrlParams();
        
        try {
            const autoLoggedIn = await AuthManager.tryAutoLogin(this);
            if (autoLoggedIn) {
                console.log('Auto-login successful, loading servers...');
                await ServerManager.loadServers(this);
                
                if (this.pendingInviteCode) {
                    console.log('Applying pending invite:', this.pendingInviteCode);
                    const inviteApplied = await InviteManager.applyPendingInvite();
                    
                    if (inviteApplied) {
                        console.log('Invite applied successfully');
                        this.clearPendingInvite();
                        this.startSyncInterval();
                        return;
                    } else {
                        console.log('Failed to apply invite, continuing with normal flow');
                    }
                }
                
                const lastServerId = localStorage.getItem('lastServerId');
                const lastRoomId = localStorage.getItem('lastRoomId');
                
                if (lastServerId) {
                    console.log('Found last server in localStorage:', lastServerId);
                    const serverExists = this.servers.some(s => s.id === lastServerId);
                    if (serverExists) {
                        this.currentServerId = lastServerId;
                        this.currentServer = this.servers.find(s => s.id === lastServerId);
                        
                        await RoomManager.loadRoomsForServer(this, lastServerId);
                        
                        if (lastRoomId) {
                            console.log('Found last room in localStorage:', lastRoomId);
                            const roomExists = this.rooms.some(room => room.id === lastRoomId);
                            
                            if (roomExists) {
                                this.currentRoom = lastRoomId;
                                await this.reconnectToRoom(lastRoomId);
                                this.startSyncInterval();
                                return;
                            }
                        }
                    }
                }
                
                let targetServerId = null;
                if (this.inviteServerId) {
                    console.log('Processing invite server ID:', this.inviteServerId);
                    const serverExists = this.servers.some(s => s.id === this.inviteServerId);
                    if (serverExists) {
                        targetServerId = this.inviteServerId;
                    } else {
                        const joined = await this.joinServer(this.inviteServerId);
                        if (joined) {
                            targetServerId = this.inviteServerId;
                            await ServerManager.loadServers(this);
                        } else {
                            UIManager.showError('Нет доступа к серверу.');
                        }
                    }
                } else if (this.currentServerId) {
                    console.log('Processing current server ID:', this.currentServerId);
                    const serverExists = this.servers.some(s => s.id === this.currentServerId);
                    if (serverExists) {
                        targetServerId = this.currentServerId;
                    }
                }
                
                if (targetServerId) {
                    console.log('Setting target server:', targetServerId);
                    this.currentServerId = targetServerId;
                    await RoomManager.loadRoomsForServer(this, targetServerId);
                    if (this.currentRoom) {
                        await this.reconnectToRoom(this.currentRoom);
                    }
                    this.startSyncInterval();
                } else {
                    console.log('No target server found, showing auto-connect UI');
                    this.autoConnect();
                }
                return;
            }
            console.log('No auto-login found, showing auth modal');
            AuthManager.showAuthModal(this);
        } catch (err) {
            console.error('Auto connect error:', err);
            UIManager.showError('Критическая ошибка: не удалось загрузить систему авторизации');
        }
    }

    clearPendingInvite() {
        console.log('Clearing pending invite');
        this.pendingInviteCode = null;
        localStorage.removeItem('pending_invite');
        
        const url = new URL(window.location);
        url.searchParams.delete('invite');
        window.history.replaceState({}, '', url);
    }

    async joinServer(serverId) {
        console.log('Joining server:', serverId);
        
        try {
            const res = await fetch(`${this.API_SERVER_URL}/api/servers/${serverId}/join`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.token}`
                },
                body: JSON.stringify({ userId: this.userId, token: this.token })
            });

            if (!res.ok) {
                const err = await res.json().catch(() => ({}));
                throw new Error(err.error || 'Не удалось присоединиться');
            }

            const data = await res.json();
            const server = data.server;

            const exists = this.servers.some(s => s.id === server.id);
            if (!exists) {
                this.servers.push(server);
                ServerManager.saveServersToLocalStorage(this);
            }

            if (this.elements.serverSearchInput) {
                this.elements.serverSearchInput.value = '';
            }

            localStorage.setItem('lastServerId', server.id);
            
            ServerManager.renderServers(this);
            this.showPanel('servers');
            
            UIManager.addMessage('System', `✅ Вы присоединились к "${server.name}"`);

            return true;

        } catch (error) {
            console.error('Error joining server:', error);
            UIManager.showError(`❌ Не удалось присоединиться: ${error.message}`);
            return false;
        }
    }

    async joinRoom(roomId) {
        console.log('Joining room:', roomId);
        
        try {
            UIManager.addMessage('System', 'Подключение к комнате...');
            
            this.disconnectFromRoom();
            
            this.setupSocketConnection();
            
            const res = await fetch(this.CHAT_API_URL, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json', 
                    'Authorization': `Bearer ${this.token}` 
                },
                body: JSON.stringify({ 
                    roomId, 
                    userId: this.userId, 
                    token: this.token, 
                    clientId: this.clientID 
                })
            });
            
            if (!res.ok) {
                const errorData = await res.json().catch(() => ({}));
                throw new Error(errorData.error || `Ошибка входа: ${res.status}`);
            }
            
            const data = await res.json();
            if (!data.success) throw new Error(data.error);
            
            this.clientID = data.clientId;
            this.mediaData = data.mediaData;
            this.currentRoom = roomId;
            this.roomType = 'voice';
            
            localStorage.setItem('lastServerId', this.currentServerId);
            localStorage.setItem('lastRoomId', this.currentRoom);
            
            await MediaManager.connect(this, roomId, data.mediaData);
            this.updateMicButtonState();
            
            if (this.socket) {
                this.socket.emit('subscribe-to-producers', { roomId });
                this.socket.emit('get-current-producers', { roomId });
            }
            
            UIManager.updateRoomUI(this);
            TextChatManager.joinTextRoom(this, roomId);
            await TextChatManager.loadMessages(this, roomId);
            
            try {
                await new Promise(resolve => setTimeout(resolve, 500));
                
                const participantsResponse = await fetch(`${this.API_SERVER_URL}/api/media/rooms/${roomId}/participants`, {
                    headers: {
                        'Authorization': `Bearer ${this.token}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (participantsResponse.ok) {
                    const participantsData = await participantsResponse.json();
                    if (participantsData.participants && Array.isArray(participantsData.participants)) {
                        console.log('[CLIENT] Инициализируем список участников с', participantsData.participants.length, 'участниками');
                        MembersManager.initializeRoomMembers(this, participantsData.participants);
                    } else {
                        console.log('[CLIENT] Пустой или некорректный список участников от сервера');
                    }
                } else {
                    console.error('[CLIENT] Ошибка при получении списка участников:', participantsResponse.status);
                }
            } catch (error) {
                console.error('[CLIENT] Ошибка запроса списка участников:', error);
            }
            
            UIManager.addMessage('System', `✅ Вы присоединились к комнате`);
            return true;
        } catch (e) {
            console.error('Error joining room:', e);
            UIManager.updateStatus('Ошибка: ' + e.message, 'disconnected');
            UIManager.showError('Не удалось присоединиться к комнате: ' + e.message);
            throw e;
        }
    }

    setupSocketConnection() {
        console.log('Setting up socket connection...');
        
        if (this.socket && this.socket.connected) {
            console.log('Socket already connected, reusing');
            return;
        }
        
        const currentToken = this.token;
        if (!currentToken) {
            console.log('No token available, skipping socket connection');
            return;
        }

        this.destroySocket();
        
        try {
            console.log('Creating new socket connection with token:', currentToken);
            this.socket = io(this.API_SERVER_URL, {
                auth: {
                    token: currentToken,
                    userId: this.userId,
                    clientId: this.clientID,
                    username: this.username
                },
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                timeout: 20000
            });

            const socket = this.socket;
            
            socket.on('new-producer', async (data) => {
                await new Promise(resolve => setTimeout(resolve, 200));
                console.log('New producer event:', data);
                if (data.clientID !== this.clientID) {
                    try {
                        await MediaManager.createConsumer(this, data.producerId);
                        this.existingProducers.add(data.producerId);
                    } catch (error) {
                        console.error('Error creating consumer:', error);
                    }
                }
            });

            socket.on('current-producers', async (data) => {
                console.log('Current producers event:', data);
                if (!data || !data.producers || !Array.isArray(data.producers)) {
                    console.log('No producers data available');
                    return;
                }

                for (const producer of data.producers) {
                    if (producer.clientID !== this.clientID && 
                        !this.existingProducers.has(producer.id)) {
                        try {
                            await MediaManager.createConsumer(this, producer.id);
                            this.existingProducers.add(producer.id);
                        } catch (error) {
                            console.error('Error creating consumer:', error);
                            if (error.message.includes('consume own')) {
                                this.existingProducers.add(producer.id);
                            }
                        }
                    }
                }
            });

            socket.on('room-participants', (participants) => {
                console.log('Room participants received:', participants);
                MembersManager.updateAllMembers(participants);
            });

            socket.on('user-joined', (user) => {
                console.log('User joined:', user);
                MembersManager.addMember(user);
                UIManager.addMessage('System', `Пользователь ${user.username} присоединился к комнате`);
            });

            socket.on('user-left', (data) => {
                console.log('User left:', data);
                MembersManager.removeMember(data.userId);
                UIManager.addMessage('System', `Пользователь покинул комнату`);
            });

            socket.on('user-mic-state', (data) => {
                console.log('User mic state changed:', data);
                if (data.userId) {
                    MembersManager.updateMember(data.userId, { isMicActive: data.isActive });
                } else {
                    const members = MembersManager.getMembers();
                    const member = members.find(m => m.clientId === data.clientID);
                    if (member) {
                        MembersManager.updateMember(member.userId, { isMicActive: data.isActive });
                    }
                }
            });

            socket.on('new-message', (message) => {
                console.log('New message received:', message);
                if (message.roomId === this.currentRoom) {
                    UIManager.addMessage(message.username, message.text, message.timestamp);
                }
            });

            socket.on('message-history', (data) => {
                console.log('Message history received:', data);
                if (data.roomId === this.currentRoom && data.messages) {
                    UIManager.clearMessages();
                    
                    data.messages.forEach(msg => {
                        UIManager.addMessage(msg.username, msg.text, msg.timestamp);
                    });
                }
            });

            socket.on('error', (error) => {
                console.error('Socket error:', error);
                UIManager.showError('Ошибка соединения: ' + (error.message || 'неизвестная ошибка'));
            });

            socket.on('connect', () => {
                console.log('✅ Socket connected with ID:', socket.id);
                UIManager.updateStatus('Подключено', 'connected');
                
                if (this.currentRoom) {
                    console.log('Rejoining room after socket reconnect:', this.currentRoom);
                    socket.emit('join-room', { roomId: this.currentRoom });
                    socket.emit('subscribe-to-producers', { roomId: this.currentRoom });
                    socket.emit('get-current-producers', { roomId: this.currentRoom });
                }
            });

            socket.on('disconnect', (reason) => {
                console.log('Socket disconnected:', reason);
                UIManager.updateStatus('Отключено', 'disconnected');
            });

        } catch (error) {
            console.error('Error setting up socket connection:', error);
            UIManager.showError('Ошибка подключения к серверу');
        }
    }

    destroySocket() {
        console.log('Destroying socket connection...');
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
    }

    updateMicButtonState() {
        let status;
        if (!this.isConnected) {
            status = 'disconnected';
        } else if (this.isMicActive) {
            status = 'active';
        } else {
            status = 'connected';
        }
        UIManager.updateMicButton(status);
    }

    async toggleMicrophone() {
        console.log('Toggling microphone, current state:', this.isMicActive);
        
        try {
            if (!this.currentRoom) {
                UIManager.showError('Микрофон доступен только в комнатах');
                return;
            }
            
            if (this.isMicActive) {
                await MediaManager.stopMicrophone(this);
                if (this.socket) {
                    this.socket.emit('mic-state-change', {
                        roomId: this.currentRoom,
                        isActive: false,
                        clientID: this.clientID,
                        userId: this.userId
                    });
                }
            } else {
                try {
                    await MediaManager.startMicrophone(this);
                    if (this.socket) {
                        this.socket.emit('mic-state-change', {
                            roomId: this.currentRoom,
                            isActive: true,
                            clientID: this.clientID,
                            userId: this.userId
                        });
                        
                        if (this.audioProducer) {
                            this.socket.emit('new-producer-notification', {
                                roomId: this.currentRoom,
                                producerId: this.audioProducer.id,
                                clientID: this.clientID,
                                kind: 'audio'
                            });
                        }
                    }
                } catch (error) {
                    if (error.message.includes('permission') || error.message.includes('разрешение')) {
                        UIManager.showError('Необходимо разрешение на использование микрофона');
                    } else {
                        throw error;
                    }
                }
            }
            this.updateMicButtonState();
        } catch (error) {
            console.error('Error toggling microphone:', error);
            UIManager.showError('Ошибка микрофона: ' + error.message);
            this.updateMicButtonState();
        }
    }

    sendMessage(text) {
        console.log('Sending message:', text);
        
        if (!text.trim()) return;
        if (!this.currentRoom) {
            this.showError('Вы не в комнате');
            return;
        }
        
        if (this.socket) {
            this.socket.emit('send-message', {
                roomId: this.currentRoom,
                text: text.trim()
            });
        } else {
            TextChatManager.sendMessage(this, text).catch((error) => {
                console.error('Error sending message:', error);
                this.showError('Ошибка отправки сообщения');
            });
        }
    }

    startSyncInterval() {
        console.log('Starting sync interval...');
        
        window.debugStartConsuming = () => this.startConsuming();
        window.debugStartSyncInterval = () => this.startSyncInterval();
        window.debugVoiceClient = this;
        
        if (this.syncInterval) clearInterval(this.syncInterval);
           
        this.syncInterval = setInterval(async () => {
            try {
                await ServerManager.loadServers(this);
                if (this.currentServerId) {
                    await RoomManager.loadRoomsForServer(this, this.currentServerId);
                }
                
                if (this.currentRoom && this.isConnected) {
                    await this.startConsuming();
                } 
            } catch (error) {
                console.error('Sync error:', error);
            }
        }, 3000);
    }

    async startConsuming() {
        console.log('Starting media consumption...');
        
        if (!this.isConnected || !this.currentRoom) {
            return;
        }
        
        try {
            const response = await fetch(`${this.API_SERVER_URL}/api/media/rooms/${this.currentRoom}/producers`, {
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                }
            });
            
            if (!response.ok) {
                return;
            }
            
            const data = await response.json();
            const producers = data.producers || [];

            for (const producer of producers) {
                if (producer.clientID !== this.clientID && !this.existingProducers.has(producer.id)) {
                    try {
                        await MediaManager.createConsumer(this, producer.id);
                        this.existingProducers.add(producer.id);
                    } catch (error) {
                        console.error('Error creating consumer:', error);
                        if (error.message.includes('consume own')) {
                            this.existingProducers.add(producer.id);
                        }
                    }
                }
            }
        } catch (error) {
            console.error('Error starting consuming:', error);
        }
    }

    async disconnectFromRoom() {
        console.log('Disconnecting from room:', this.currentRoom);
        
        if (this.currentRoom) {
            if (this.socket) {
                this.socket.emit('leave-room', { roomId: this.currentRoom });
            }
            
            MediaManager.disconnect(this);
            
            TextChatManager.leaveTextRoom(this, this.currentRoom);
            
            MembersManager.clearMembers();
            
            this.destroySocket();
            this.currentRoom = null;
            this.isConnected = false;
            this.isMicActive = false;
            this.existingProducers.clear();
            this.updateMicButtonState();
        }
    }

    async reconnectToRoom(roomId) {
        console.log('Reconnecting to room:', roomId);
        
        try {
            UIManager.addMessage('System', 'Переподключение к комнате...');
            
            this.wasMicActiveBeforeReconnect = this.isMicActive;
            
            if (this.isMicActive && this.mediaData) {
                await MediaManager.stopMicrophone(this);
            }
            
            await this.leaveRoom();
            
            this.isReconnecting = true;
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            const result = await this.joinRoom(roomId);
            
            this.isReconnecting = false;
            
            if (this.wasMicActiveBeforeReconnect && this.mediaData) {
                setTimeout(async () => {
                    try {
                        await MediaManager.startMicrophone(this);
                        this.wasMicActiveBeforeReconnect = false;
                    } catch (error) {
                        UIManager.showError('Не удалось восстановить микрофон после переподключения');
                    }
                }, 1000);
            }
            
            return result;
        } catch (error) {
            this.isReconnecting = false;
            UIManager.addMessage('System', 'Ошибка переподключения: ' + error.message);
            throw error;
        }
    }

    async leaveRoom() {
        console.log('Leaving room:', this.currentRoom);
        
        if (!this.currentRoom) return;
        
        try {
            if (this.socket) {
                this.socket.emit('leave-room', { roomId: this.currentRoom });
            }
            
            if (this.isConnected) {
                MediaManager.disconnect(this);
            }
            
            await fetch(`${this.API_SERVER_URL}/api/media/rooms/${this.currentRoom}/leave`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                }
            });
            
            MembersManager.clearMembers();
            
            this.currentRoom = null;
            this.roomType = null;
            
            UIManager.updateRoomUI(this);
            UIManager.addMessage('System', `✅ Вы покинули комнату`);
            return true;
        } catch (error) {
            console.error('Error leaving room:', error);
            UIManager.showError('Ошибка при покидании комната: ' + error.message);
            return false;
        }
    }

    autoConnect() {
        console.log('Showing auto-connect UI');
        this.elements.sidebar.classList.add('open');
    }

    showMessage(user, text) {
        UIManager.addMessage(user, text);
    }

    showError(text) {
        UIManager.showError(text);
    }

    async searchServers(query) {
        console.log('Searching servers:', query);
        await ServerManager.searchServers(this, query);
    }

    async checkRoomState() {
        if (!this.currentRoom) {
            console.log('No current room to check');
            return;
        }
        
        try {
            const response = await fetch(`${this.API_SERVER_URL}/api/debug/room/${this.currentRoom}`, {
                headers: {
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                }
            });
            
            if (response.ok) {
                const roomState = await response.json();
                console.log('🏠 Room state:', roomState);
                
                const ourTransport = roomState.transports.find(t => t.clientID === this.clientID && t.direction === 'recv');
                console.log('📡 Our receive transport:', ourTransport);
                
                const ourConsumers = roomState.consumers.filter(c => c.clientID === this.clientID);
                console.log('🎧 Our consumers:', ourConsumers);
                
                return roomState;
            } else {
                console.error('Failed to get room state:', response.status);
            }
        } catch (error) {
            console.error('Error checking room state:', error);
        }
    }
}

export default VoiceChatClient;


styles.css:
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    --bg-primary: #36393f;
    --bg-secondary: #2f3136;
    --bg-tertiary: #202225;
    --bg-modifier: rgba(79, 84, 92, 0.16);
    --text-normal: #dcddde;
    --text-muted: #72767d;
    --accent: #5865f2;
    --success: #3ba55d;
    --danger: #ed4245;
    --warning: #faa61a;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: var(--bg-primary);
    color: var(--text-normal);
    height: 100vh;
    overflow: hidden;
}

.app {
    display: flex;
    height: 100vh;
    position: relative;
}

/* Sidebar Styles */
.sidebar {
    width: 240px;
    background: var(--bg-secondary);
    display: flex;
    flex-direction: column;
    border-right: 1px solid var(--bg-tertiary);
    transition: transform 0.3s ease;
}

.sidebar-header {
    padding: 12px;
    display: flex;
    border-bottom: 1px solid var(--bg-tertiary);
    background: var(--bg-tertiary);
}

.search-container {
    display: flex;
    align-items: center;
    padding: 8px 16px;
    border-bottom: 1px solid var(--bg-tertiary);
    gap: 8px;
}

.search-input {
    width: 100%;
    padding: 8px 12px;
    border-radius: 4px;
    border: none;
    background: var(--bg-modifier);
    color: var(--text-normal);
    outline: none;
}

.clear-search-btn {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 4px;
    border-radius: 3px;
    font-size: 14px;
}

.clear-search-btn:hover {
    background: var(--bg-modifier);
    color: var(--text-normal);
}

.panel-toggle-btn {
    flex: 1;
    padding: 8px;
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    border-radius: 4px;
    margin: 0 2px;
}

.panel-toggle-btn.active {
    background: var(--accent);
    color: white;
}

.close-sidebar-btn {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 3px;
    margin-left: 4px;
}

.close-sidebar-btn:hover {
    background: var(--bg-modifier);
    color: var(--text-normal);
}

.panel-content {
    display: none;
    flex-direction: column;
    flex: 1;
    overflow: hidden;
}

.panel-content.active {
    display: flex;
}

.panel-header {
    padding: 12px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid var(--bg-tertiary);
}

.servers-list, .rooms-list {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
}

.server-item, .room-item {
    padding: 8px 12px;
    border-radius: 4px;
    margin-bottom: 4px;
    cursor: pointer;
    transition: background 0.2s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    position: relative;
}

.server-item:hover, .room-item:hover {
    background: var(--bg-modifier);
}

.server-item.active, .room-item.active {
    background: var(--accent);
}

.owner-badge {
    font-size: 12px;
    color: var(--text-muted);
    margin-left: 4px;
}

.not-member-badge {
    font-size: 12px;
    color: var(--text-muted);
    margin-left: 4px;
}

.server-actions, .room-actions {
    display: flex;
    gap: 4px;
    margin-left: auto;
}

.server-action-btn, .room-action-btn {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 3px;
    font-size: 12px;
    opacity: 0.7;
    transition: opacity 0.2s ease;
}

.server-action-btn:hover, .room-action-btn:hover {
    opacity: 1;
    color: var(--text-normal);
    background: var(--bg-modifier);
}

.server-action-btn.leave-btn {
    color: var(--warning);
}

.server-action-btn.leave-btn:hover {
    background: var(--warning);
    color: white;
}

.server-action-btn.join-btn {
    color: var(--success);
}

.server-action-btn.join-btn:hover {
    background: var(--success);
    color: white;
}

.create-server-btn, .create-room-btn {
    background: none;
    border: none;
    color: var(--success);
    cursor: pointer;
    font-size: 18px;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 3px;
}

.create-server-btn:hover, .create-room-btn:hover {
    background: var(--bg-modifier);
}

/* Main Content Styles */
.main-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 0;
}

.chat-header {
    padding: 0 16px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid var(--bg-tertiary);
    background: var(--bg-secondary);
}

.toggle-sidebar-btn {
    display: none;
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 18px;
    width: 32px;
    height: 32px;
    border-radius: 4px;
}

.toggle-sidebar-btn:hover {
    background: var(--bg-modifier);
    color: var(--text-normal);
}

.header-controls {
    display: flex;
    align-items: center;
    gap: 4px;
}

.mic-toggle-btn, .settings-btn, .toggle-members-btn {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 18px;
    width: 32px;
    height: 32px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mic-toggle-btn:hover, .settings-btn:hover, .toggle-members-btn:hover {
    background: var(--bg-modifier);
}

.mic-toggle-btn.disconnected {
    color: var(--text-muted);
}

.mic-toggle-btn.connected {
    color: var(--danger);
}

.mic-toggle-btn.error {
    color: var(--warning);
}

.mic-toggle-btn.active {
    color: var(--success);
}

.chat-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.messages-container {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
}

.message {
    margin-bottom: 16px;
    display: flex;
    gap: 12px;
    opacity: 0;
    transform: translateY(10px);
    transition: opacity 0.3s ease, transform 0.3s ease;
}

.message.appeared {
    opacity: 1;
    transform: translateY(0);
}

.message-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--accent);
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    flex-shrink: 0;
}

.message-content {
    flex: 1;
}

.message-header {
    display: flex;
    align-items: baseline;
    gap: 8px;
    margin-bottom: 4px;
}

.message-username {
    font-weight: 600;
}

.message-time {
    font-size: 12px;
    color: var(--text-muted);
}

.message-text {
    line-height: 1.4;
}

.input-area {
    padding: 16px;
    border-top: 1px solid var(--bg-tertiary);
    display: flex;
    gap: 8px;
}

.message-input {
    flex: 1;
    padding: 12px;
    border-radius: 8px;
    border: none;
    background: var(--bg-modifier);
    color: var(--text-normal);
    outline: none;
}

.message-input:focus {
    background: var(--bg-tertiary);
}

.send-btn {
    background: var(--accent);
    border: none;
    border-radius: 8px;
    color: white;
    padding: 0 16px;
    cursor: pointer;
}

.send-btn:hover {
    background: #4752c4;
}

/* Members Panel Styles */
.members-panel {
    width: 240px;
    background: var(--bg-secondary);
    border-left: 1px solid var(--bg-tertiary);
    display: flex;
    flex-direction: column;
    transition: transform 0.3s ease;
}

.members-panel .panel-header {
    padding: 12px 16px;
}

.close-panel-btn {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 18px;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 3px;
}

.close-panel-btn:hover {
    background: var(--bg-modifier);
    color: var(--text-normal);
}

.members-list {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
}

.member-item {
    padding: 8px 12px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.member-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: var(--accent);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: bold;
    flex-shrink: 0;
}

.member-name {
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.member-status {
    display: flex;
    gap: 4px;
    align-items: center;
}

/* Новые стили для индикаторов статуса */
.status-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
}

.status-indicator.online {
    background: var(--success);
}

.status-indicator.offline {
    background: var(--text-muted);
}

.mic-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--text-muted);
    position: relative;
}

.mic-indicator.active {
    background: var(--success);
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

/* Modal Styles */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.modal-content {
    background: var(--bg-secondary);
    border-radius: 8px;
    padding: 20px;
    min-width: 300px;
    max-width: 500px;
    width: 90%;
    color: var(--text-normal);
}

.modal-content h2 {
    margin-bottom: 16px;
}

.saved-users-list {
    max-height: 200px;
    overflow-y: auto;
    margin-bottom: 15px;
}

.no-users-message {
    color: var(--text-muted);
    text-align: center;
    padding: 10px;
}

.saved-user-item {
    padding: 8px 10px;
    margin: 4px 0;
    background: var(--bg-modifier);
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.saved-user-item:hover {
    background: var(--bg-tertiary);
}

.remove-user-btn {
    background: var(--danger);
    color: white;
    border: none;
    padding: 2px 6px;
    border-radius: 3px;
    cursor: pointer;
}

#usernameInput, #passwordInput {
    width: 100%;
    padding: 12px;
    margin: 8px 0;
    background: var(--bg-modifier);
    border: 1px solid var(--bg-tertiary);
    border-radius: 4px;
    color: var(--text-normal);
}

#authSubmitBtn, #createNewUserBtn {
    width: 100%;
    padding: 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-top: 8px;
}

#authSubmitBtn {
    background: var(--accent);
    color: white;
}

#createNewUserBtn {
    background: var(--bg-modifier);
    color: var(--text-normal);
}

.modal-buttons {
    display: flex;
    gap: 10px;
    margin-top: 15px;
}

.modal-buttons button {
    flex: 1;
    padding: 10px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

#confirmCreateRoom {
    background: var(--accent);
    color: white;
}

#cancelCreateRoom {
    background: var(--bg-modifier);
    color: var(--text-normal);
}

.setting-item {
    margin-bottom: 16px;
}

.setting-item label {
    display: flex;
    align-items: center;
    gap: 8px;
}

.apply-settings-btn {
    width: 100%;
    padding: 12px;
    background: var(--accent);
    border: none;
    border-radius: 4px;
    color: white;
    cursor: pointer;
    margin-top: 16px;
}

.apply-settings-btn:hover {
    background: #4752c4;
}

.hidden {
    display: none;
}

/* Microphone Button Styles */
.mic-button {
    position: fixed;
    right: 20px;
    bottom: 20px;
    width: 56px;
    height: 56px;
    border-radius: 50%;
    border: none;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    cursor: pointer;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    z-index: 100;
    transition: transform 0.3s ease, opacity 0.3s ease, background-color 0.3s ease;
}

.mic-button.disconnected {
    background: var(--text-muted);
}

.mic-button.connected {
    background: var(--danger);
}

.mic-button.active {
    background: var(--success);
}

.mic-button.error {
    background: var(--warning);
    animation: pulse 1s infinite;
}

.mic-button.hidden {
    transform: scale(0);
    opacity: 0;
}

/* Invite Link Styles */
.invite-link-container {
    display: flex;
    gap: 8px;
    margin: 16px 0;
}

#inviteLinkInput {
    flex: 1;
    padding: 8px 12px;
    border: 1px solid var(--bg-tertiary);
    border-radius: 4px;
    background: var(--bg-modifier);
    color: var(--text-normal);
    font-family: monospace;
}

.invite-link-container button {
    padding: 8px 12px;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.invite-link-container button:hover {
    background: #4752c4;
}

/* Error Message Styles */
.error-message {
    position: fixed;
    top: 20px;
    right: 20px;
    background: var(--danger);
    color: white;
    padding: 10px 15px;
    border-radius: 5px;
    z-index: 1000;
    max-width: 300px;
    animation: slideIn 0.3s ease;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

/* Status Styles */
.status-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 8px;
    display: inline-block;
}

.status-indicator.connecting {
    background: var(--warning);
    animation: pulse 1.5s infinite;
}

.status-indicator.disconnected {
    background: var(--danger);
}

.status-indicator.connected {
    background: var(--success);
}

.status-text {
    font-size: 14px;
    color: var(--text-muted);
}

.no-results {
    padding: 16px;
    text-align: center;
    color: var(--text-muted);
}

/* Responsive Styles */
@media (max-width: 768px) {
    .sidebar {
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        z-index: 100;
        transform: translateX(-100%);
        width: 280px;
    }
    
    .sidebar.open {
        transform: translateX(0);
    }
    
    .members-panel {
        position: fixed;
        right: 0;
        top: 0;
        bottom: 0;
        z-index: 100;
        transform: translateX(100%);
    }
    
    .members-panel.open {
        transform: translateX(0);
    }
    
    .toggle-sidebar-btn {
        display: flex;
    }
    
    .mic-button {
        display: none;
    }
    
    .mic-toggle-btn {
        display: flex;
    }
    
    .server-actions, .room-actions {
        flex-direction: column;
        gap: 2px;
    }
    
    .server-action-btn, .room-action-btn {
        padding: 4px;
        font-size: 14px;
    }
    
    .invite-link-container {
        flex-direction: column;
    }
}


